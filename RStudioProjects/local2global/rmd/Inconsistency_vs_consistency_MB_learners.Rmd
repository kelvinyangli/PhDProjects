---
title: "Inconsistency vs consistency MB learners"
author: "Kelvin Li"
date: "14 January 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE, echo = T, eval = T)
if (.Platform$OS.type == "windows") {
  dir = "C:/Users/"
} else {
  dir = "/home/"
}
source(paste0(dir, "kl/Documents/PhDProjects/RStudioProjects/local2global/scripts/load_libraries.R"))
#library(plyr)
library(igraph)
library(foreign) # for writing data into .arff format for camml
library(wrsgraph)
library(R.utils)
library(plotrix)
```


## generate BNs and learn MBs 
```{r}
<<<<<<< HEAD
dir = "~/Documents/Experiments/camml_moral_graph_test_11_apr_2019/"
nTimes = 50 # number of random models 
mtxImmoral = mtxMoral = matrix(0, ncol = 8, nrow = nTimes)
nFillin = rep(0, nTimes)

confidence = 0.5 # confidence level of arc prior

# model specification
nvars = 30
maxNPas = 5
maxArity = 2
beta = 1
n = 100
=======
dir = "~/Documents/Experiments/camml_moral_graph_test_06_may_2019/"
nTimes = 10 # number of random models 
mtxImmoral = mtxMoral = matrix(0, ncol = 8, nrow = nTimes)
nFillin = rep(0, nTimes)

confidence = 0.6 # confidence level of arc prior

# model specification
nvars = 50
maxNPas = 4
maxArity = 2
beta = 1
n = 1000
>>>>>>> master

cnt = 1
while(cnt < (nTimes + 1)) {

# generate models
seed = randSeed()
dag = randDag(nvars, maxNPas)
g = dag2matrix(moral(dag)) # store dag into adj mtx 
cpts = randCPTs(dag, maxArity, beta)
data = rbn(cpts, n)
vars = colnames(data)
data_cat = numeric2categorical(data)
arities = sapply(data_cat, nlevels)
di = varCnt = count_occurance(data_cat, arities)

## learn mbs using parallel mmlcpt 
registerDoParallel(3) # use 3 cores 
res = foreach(target = vars,
    .combine = list,
    .multicombine = TRUE) %dopar% {
    forward_greedy_fast(data, di, arities, vars, n, target)
    }
stopImplicitCluster()
mbcpt = res
names(mbcpt) = names(res) = vars
mbcpt = symmetry_correction(vars, mbcpt, "AND")

# form an undirected graph
G = matrix(0, nvars, nvars)
dimnames(G) = list(vars, vars)
for (x in vars) {
  G[x, mbcpt[[x]]] = 1
}

# only keep the case when G is not wrs 
GIsWRS = withTimeout(wrsgraph::wrs_bktr(G, G)$wrs, timeout = 30, onTimeout = "silent")
if (length(GIsWRS) > 0) {
  if (GIsWRS == 0) {
    cat(cnt, "\n")
    
    H = min_deg_moralization(G)
    dist_G = unlist(edit_dist_graph(G, g)) # calculate hamming dist
    dist_H = unlist(edit_dist_graph(H, g)) # calculate hamming dist
    mtxImmoral[cnt, ] = dist_G
    mtxMoral[cnt, ] = dist_H
    nFillin[cnt] = sum(H - G) / 2
    
    # save data, dag, cpt, mbl 
    write.csv(data, paste0(dir, "data/data_", n, "_", seed, ".csv"), row.names = F)
    saveRDS(dag, paste0(dir, "dag/dag_", n, "_", seed, ".rds"))
    saveRDS(cpts, paste0(dir, "cpts/cpts_", n, "_", seed, ".rds"))
    saveRDS(res, paste0(dir, "mb_learned_asym/mb_", n, "_", seed, ".rds"))
    
    # immoral graph prior
    text = "arcs {"
    for (i in 1:nrow(G)) {
      for (j in i:ncol(G)) {
        if (G[i,j] == 1) {
          text = paste(text, "\n", vars[i], "--", vars[j], confidence, ";")  
        }
      }
    }
    text = paste(text, "\n }")
    write_file(text, paste0(dir, confidence, "/prior_im/prior_im_", n, "_", seed, ".txt"))
    
    # moral graph prior
    text = "arcs {"
    for (i in 1:nrow(H)) {
      for (j in i:ncol(H)) {
        if (H[i,j] == 1) {
          text = paste(text, "\n", vars[i], "--", vars[j], confidence, ";")  
        }
      }
    }
    text = paste(text, "\n }")
    write_file(text, paste0(dir, confidence, "/prior_m/prior_m_", n, "_", seed, ".txt"))
    
    cnt = cnt + 1
    
    }
}
}

```

## analysis
```{r}
immoralMeans = colMeans(mtxImmoral)
moralMeans = colMeans(mtxMoral)
immoralSDs = apply(mtxImmoral, 2, sd)
moralSDs = apply(mtxMoral, 2, sd)
<<<<<<< HEAD
imLower = immoralMeans - 1.96 * immoralSDs / sqrt(100)
imUpper = immoralMeans + 1.96 * immoralSDs / sqrt(100)
mLower = moralMeans - 1.96 * moralSDs / sqrt(100)
mUpper = moralMeans + 1.96 * moralSDs / sqrt(100)
=======
imLower = immoralMeans - 1.96 * immoralSDs / sqrt(nTimes)
imUpper = immoralMeans + 1.96 * immoralSDs / sqrt(nTimes)
mLower = moralMeans - 1.96 * moralSDs / sqrt(nTimes)
mUpper = moralMeans + 1.96 * moralSDs / sqrt(nTimes)
>>>>>>> master

names = c("TP", "FP", "TN", "FN", "precision", "recall", "F1", "edit_dist")
par(mfrow=c(4,2))
for (k in 1:length(immoralMeans)) {
means = c(moralMeans[k], immoralMeans[k])
<<<<<<< HEAD
sds = c(1.96 * moralSDs[k] / sqrt(100), 1.96 * immoralSDs[k] / sqrt(100))
=======
sds = c(1.96 * moralSDs[k] / sqrt(nTimes), 1.96 * immoralSDs[k] / sqrt(nTimes))
>>>>>>> master
plotCI(barplot(means,col="gray",ylim=c(0,max(means+sds)),width=1,ylab = names[k],xlab =""),means,sds,add = TRUE)
axis(side=1,at=1:2,label=c("moral", "immoral"))
}
```


## minimum degree heuristic to obtain a moral graph
```{r}
# at each step when there is no simplicial node, choose the node in the current elimination graph with the minimum degree, and fill in its deficiency. 
# is this trivial/obvious?
g = rand_bounded_deg_graph(30, 5)
isWRS = wrs_bktr(g, g)$wrs
if (isWRS == 0) {
  cat("start moralization... \n")
  G = g
  H = min_deg_moralization(g)
  # the number of fill in edges 
  #H - G
  cat("# fill in edges:", sum(H - G) / 2, "\n")
  #(wrs_bktr(H, H)$wrs)
}
```


## change camml prior confidence 
```{r}
col = "m"
files = list.files(paste0(dir, "prior_", col, "_0.95"))
for (i in 1:length(files)) {
  
  prior = read_file(paste0(dir, "prior_", col, "_0.95/", files[i]))
  prior = gsub("0.95", "1", prior)
  write_file(prior, paste0(dir, "prior_", col, "_1/", files[i]))
}
```

## produce true model prior 
```{r}
confidence = 0.3
files = list.files(paste0(dir, "dag"))
for (i in 1:length(files)) {
  dag = readRDS(paste0(dir, "dag/", files[i]))
  g = dag2matrix(moral(dag))
  seed = strsplit(strsplit(files[i], ".rds")[[1]], "_")[[1]][[3]]
  
  #vars = colnames(G)
  
  # immoral graph prior
  text = "arcs {"
  for (i in 1:nrow(g)) {
    for (j in i:ncol(g)) {
      if (g[i,j] == 1) {
        text = paste(text, "\n", vars[i], "--", vars[j], confidence, ";")  
      }
    }
  }
  text = paste(text, "\n }")
  write_file(text, paste0(dir, confidence, "/prior_true_m/prior_true_m_", n, "_", seed, ".txt"))
}
```


## evaluation
evaluation results on 30_5_4_1 with 1000 samples suggests there is no statistical significance b/w mb accuracy with and without enforcing morality. 
Given (moral, immoral, and true moral) mb prior to camml with 0.95 confidcen, there is no statistical significance b/w the learned patterns. The accraucy is measured by edit distance. 
```{r}
confidence = 0.3
dir = "~/Documents/Experiments/camml_moral_graph_test_11_apr_2019/"
dagEdMtx = matrix(0, nrow = 100, ncol = 4)
names = c("no", "im", "m", "true_m")
colnames(dagEdMtx) = names 
for (j in c(1,4)) {
col = names[j]
#col = "no"
files = list.files(paste0(dir, confidence, "/dag_camml_", col, "_prior/"))
dags = list.files(paste0(dir, "dag/"))
#colnames(ed_matrix) = c("noPiror", rev(probs))
#rownames(ed_matrix) = c(paste("dag", 1:10), "mean")
for (i in 1:length(files)) {
  dag = readRDS(paste0(dir, "dag/", dags[i]))
  dagl = parentsList2BN(netica2bnlearn(paste0(dir, confidence, "/dag_camml_", col, "_prior/", files[i])))
  dagEdMtx[i, col] = bnlearn::shd(dagl, dag)
  
}
}
colMeans(dagEdMtx)
round(1.96*apply(dagEdMtx, 2, sd)/sqrt(n),2)
```

# edit distance b/w undirected graphs and dags 
```{r}
# edit distance b/w two undirected graphs which are stored in adjacency matrices
edit_dist_graph = function(learned, true, debug = FALSE) {
  tp = tn = fp = fn = 0
  for (i in 1:(nrow(true) - 1)) {
    for (j in (i + 1):ncol(true)) {
      if ((true[i, j] == 1) && (learned[i, j] == 1)) {
        tp = tp + 1
      } else if ((true[i, j] == 1) && (learned[i, j] == 0)) {
        fn = fn + 1
      } else if ((true[i, j] == 0) && (learned[i, j] == 1)) {
        fp = fp + 1
      } else {
        tn = tn + 1
      }
    }
  }  
  pre = round(tp / (tp + fp), 2)
  rec = round(tp / (tp + fn), 2)
  f1 = round(2 * pre * rec / (pre + rec), 2)
  if (debug) {
    cat("tp:", tp, "fp:", fp, "fn:", fn, "tn:", tn, "\n")
    cat("pre:", pre, "rec:", rec, "f1:", f1, "ed:", fp + fn, "\n")
  }
  lst = list(tp = tp, fp = fp, tn = tn, fn = fn, pre = pre, rec = rec, 
             f1 = f1, ed = fp + fn)
  return(lst)
}

# edit distance between dags
# this is the same function as the hammingDags function used in autoEditDistance in bn evaluations
edit_dist_dag = function(learned, true, debug = FALSE) {
  
  arcsLearned = directed.arcs(learned) 
  
  arcsTrue = directed.arcs(true)
  
  addition = 0
  deletion = 0
  reversion = 0
  
  # checkTrue = 0 means arc in true not in learned
  # hence addition add 1
  # checkTrue = -1 means arc in both but wrong direction
  # hence reversion add 1
  
  if ((nrow(arcsTrue) == 0) && (nrow(arcsLearned) > 0)) {
    
    # if dagTrue is empty but not dagLearned 
    deletion = nrow(arcsLearned)
    if (debug) cat("All arcs in the learned dag need to be deleted. \n")
    
  } else if ((nrow(arcsTrue) > 0) && (nrow(arcsLearned) == 0)) {
    
    # if dagLearned is empty but not dagTrue
    addition = nrow(arcsTrue)
    if (debug) cat("All arcs in the true dag need to be added to the learned dag. \n")
    
  } else if ((nrow(arcsTrue) > 0) && (nrow(arcsLearned) > 0)) {
    
    # if both dags are not empty
    for (i in 1:nrow(arcsTrue)) {
      
      # check if each arc in true appears in learned with the correct or reversed direction
      # as there can be only one 1 or -1, then sum up all results
      checkTrue = sum(apply(arcsLearned, 1, checkArc, x = arcsTrue[i,]))
      
      if (checkTrue == 0) {
        
        addition = addition + 1
        if (debug) {
          
          cat("* arcs between", arcsTrue[i,][[1]], "and", arcsTrue[i,][[2]], "do not match (addition). \n")
          cat("  > the learned network contains no arc between", arcsTrue[i,][[1]], "and", arcsTrue[i,][[2]], ". \n")
          cat("  > the true network contains", arcsTrue[i,][[1]], "->", arcsTrue[i,][[2]], ". \n")
          
        } # end debug
        
      } else if (checkTrue == -1) {
        
        reversion = reversion + 1
        if (debug) {
          
          cat("* arcs between", arcsTrue[i,][[1]], "and", arcsTrue[i,][[2]], "do not match (reversion). \n")
          cat("  > the learned network contains", arcsTrue[i,][[2]], "->", arcsTrue[i,][[1]], ". \n")
          cat("  > the true network contains", arcsTrue[i,][[1]], "->", arcsTrue[i,][[2]], ". \n")
          
        } # end debug
        
      } # end else if
      
    } # end for i
    
    for (j in 1:nrow(arcsLearned)) {
      
      # check if each arc in learned appears in true
      # as there can be only one 1 or -1, sum up all results
      checkLearned = sum(apply(arcsTrue, 1, checkArc, x = arcsLearned[j,]))
      
      if (checkLearned == 0) {
        
        deletion = deletion + 1
        if (debug) {
          
          cat("* arcs between", arcsLearned[j,][[1]], "and", arcsLearned[j,][[2]], "do not match (deletion). \n")
          cat("  > the learned network contains", arcsLearned[j,][[1]], "->", arcsLearned[j,][[2]], ". \n")
          cat("  > the true network contains no arc between", arcsLearned[j,][[1]], "and", arcsLearned[j,][[2]], ". \n")
          
        } # end debug
      
      } # end if 
      
    } # end for j
    
  }
  
  return(sum(addition, deletion, reversion))
  
}
```

# netica dne file to bnlearn dag format 
```{r}
# this function reads camml output .dne file into R as text file 
# then parse the camml output to get a parent list for all nodes
netica2bnlearn = function(directory) {
  
  text = read_file(directory)
  bnInfo = strsplit(text, "node")[[1]][-1]
  allNodes = vector(length = length(bnInfo))
  parentsList = list()
  
  for (i in 1:length(bnInfo)) {
    
    info = strsplit(bnInfo[i], "\n\t")[[1]]
    allNodes[i] = trimws(gsub("[[:punct:]]", "", info[1]))
    parents = trimws(gsub("[[:punct:]]", "", strsplit(info[6], "=")[[1]][2]))
    
    if (nchar(parents) > 0) {# if there is at least one parent
      
      parentsList[[i]] = strsplit(parents, " ")[[1]]
      
    } else {# if there is no parent
      
      parentsList[[i]] = vector()
      
    } # end else
    
  } # end for i
  
  names(parentsList) = allNodes
  
  ls = list(allNodes, parentsList)
  names(ls) = c("node", "parent")
  
  return(ls)
  
}

# resultList is a list returned by netica2bnlearn, it contains nodes and parentsList
parentsList2BN = function(resultList) {
  
  dag = empty.graph(resultList$node)
  
  for (i in 1:length(resultList$parent)) {# add directed arc from its parents to each node i
    
    if (length(resultList$parent[[i]]) > 0) {# only add arc if there is at least 1 parent for node i
      
      for (j in 1:length(resultList$parent[[i]])) {# for each parent j 
        
        dag = set.arc(dag, resultList$parent[[i]][j], resultList$node[i])
        
      }# end for j 
      
    }# end if 
    
  }# end for i
  
  return(dag)
  
}
```




