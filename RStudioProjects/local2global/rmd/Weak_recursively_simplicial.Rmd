---
title: "Weak recursively simplicial"
author: "Kelvin Li"
date: "21 May 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE, echo = F, eval = T)
if (.Platform$OS.type == "windows") {
  dir = "C:/Users/"
} else {
  dir = "/home/"
}
source(paste0(dir, "kl/Documents/PhDProjects/RStudioProjects/local2global/scripts/load_libraries.R"))
#library(plyr)
library(igraph)
#library(svMisc)
library(wrsgraph)
```

## randomly generating undirected graphs
```{r}
# failed examples, seed 2268, 79640, 62562
n = 10000
for (i in 1:n) {

  progress(i, 100, n)
  #repeat {
    seed = randSeed()
    set.seed(seed)
    # dag = randDag(30, 3)
    # g = moral(dag)
    # G = dag2matrix(g)
    # vars = colnames(G)
    G = rand_bounded_deg_graph(15, 4)
    #cat(seed, "-")
    #if (!wrsgraph::is_chordal(G)) break
  #}
  
  # g = matrix2dag(G)
  # vars = colnames(G)
  # m.deg = max(sapply(sapply(vars, bnlearn::nbr, x = g), length))
  # checking chordality using wrs and quasi rs (qrs)
  wrs = wrs_bktr(G, G)$wrs # wrs
  dwrs = d_wrs_deg4(G) # qrs
  #dwrs = d_wrs(G, G)$wrs
  #if (wrs == 1) break
  # all max.deg<=3 graphs must be both qrs and wrs
  if (wrs != dwrs) break
  
}
i
#seed
#m.deg

## plotting
g = G
G = prune_leaves(G)
#dag = readRDS("~/Documents/wrs_graph_counter_examples/0302018_1345.rds")
# g = moral(dag)
# G = dag2matrix(g)

#par(mfrow=c(1,2))
graphviz.plot(matrix2dag(G))
#graphviz.plot(matrix2dag(G), shape = "rectangle")

write.table(G,"~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx.csv", row.names = F, col.names = F)
nds = as.integer(sapply(colnames(G), gsub, pattern = "[^0-9]", replacement = ""))
write.table(nds, "~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx_nodes.csv", row.names = F, col.names = F)
```


# compare mb
```{r}
res = wrs_bktr(G, D = G, T)
dd = res$dag
dd = matrix2dag(dd)
dagl = cextend(dd)
gEdges = g$arcs
daglEdges = skeleton(dagl)$arcs
removedEdges = matrix(0, 0, 2)
for (i in 1:nrow(gEdges)) {
  if (is.na(row.match(gEdges[i, ], daglEdges))) {
    removedEdges = rbind(removedEdges, gEdges[i, ])
  }
}
removedEdges = remove_duplicated_edges(removedEdges)
if (length(removedEdges) == 2) removedEdges = matrix(removedEdges, 1, 2)
hybridl = dagl
for (i in 1:nrow(removedEdges)) hybridl = set.edge(hybridl, removedEdges[i, 1], removedEdges[i, 2])
par(mfrow=c(1,3))
graphviz.plot(dag)
graphviz.plot(g, shape = "rectangle")
graphviz.plot(dagl, shape = "rectangle")
#graphviz.plot(hybridl, highlight = list("arcs" = removedEdges), shape = "rectangle")
acyclic(dagl)
vars = bnlearn::nodes(dag)
all.equal(sapply(vars, mb, x = dagl), sapply(vars, mb, x = dag))
bnlearn::hamming(dagl, dag) # skeleton dif
bnlearn::shd(dagl, dag) # pattern dif
mean(sapply(vars, bnlearn::degree, object = dagl))
mean(sapply(vars, bnlearn::degree, object = dag))
```

## functions
1. a function to find nbrs
2. a function to identify clique among vars
3. a function to test simplicity of a node
4. a function to find all simplicial nodes 
```{r}
# a function to compute the total degree of a node in an undirected graph


# identify if a given set of nodes are simplicial in a graph
# names(nbrsList) must contain the given nodes
are_simplicial = function(graph, nodes) {
  
  sim = rep(0, length(nodes))
  i = 1
  for (x in nodes) {
    sim[i] = is_simplicial(graph, x)
    i = i + 1
  }
  return(sim)
  
}

# check if a graph is empty
is_empty_graph = function(graph) {
  
  empty = 0
  if (sum(graph) < 1) empty = 1
  return(empty)
  
}



# a function to list all edges
edge_set = function(graph, nodes) {
  
  m = matrix(0, ncol = 2, nrow = sum(graph[nodes, nodes]) / 2)
  k = 1
  for (i in 1:(length(nodes) - 1)) {
    for (j in (i + 1):length(nodes)) {
      m[k, ] = c(nodes[c(i, j)])
      k = k + 1
    }
  }
  return(m)
  
}

# a function to find the minimal edges cut to make a non-sim node x into a sim node in subG
# subset is a vector of nodes that must be appeared in all cliques, it could be empty
minimal_edges_cut = function(subG, x, xNbrs, subset) {
  
  # the task here is to find the maximal clique from c(removed, remained) 
  # that contains all nodes in remained
  ig = igraph::graph_from_adjacency_matrix(subG[xNbrs, xNbrs], mode = "undirected")
  # run cliques(ig, min = 3) to find all cliques w/ >= 3 nodes 
  # and idenfity the maximal clique containing remained 
  # if no such a clique then the minimal edge cut to make node sim 
  # is the set of edges b/w nodea nd removed 
  allQ = cliques(ig, min = length(subset))
  qSizes = sapply(allQ, length)
  keep = rep(1, length(allQ))
  if (length(subset) > 0) {
    for (i in 1:length(allQ)) {
      if (prod(subset %in% names(allQ[[i]])) == 0) keep[i] = 0
    }
  }
  
  maxQSize = qSizes[max(which(keep == 1))]
  maxQList = allQ[keep == 1][which(qSizes[keep == 1] == maxQSize)]
  edgesCut = rep(list(NULL), length(maxQList))
  for (i in 1:length(maxQList)) {
    edgesCut[[i]] = c(edgesCut[[i]], xNbrs[!xNbrs %in% names(maxQList[[i]])])
  }
  return(edgesCut)
  
}

# find all possible edge cut that makes x a sim node in the remaining graph
# the output is a list of edge cut, ordered from min to max # of edges
all_edges_cut = function(subG, x, xNbrs, subset) {
  
  ig = igraph::graph_from_adjacency_matrix(subG[xNbrs, xNbrs], mode = "undirected")
  allQ = cliques(ig, min = length(subset))
  keep = rep(1, length(allQ))
  if (length(subset) > 0) {
    for (i in 1:length(allQ)) {
      if (prod(subset %in% names(allQ[[i]])) == 0) keep[i] = 0
    }
  }
  allQ = allQ[keep == 1]
  lst = list()
  for (i in 1:length(allQ)) {
      lst[[i]] = xNbrs[!xNbrs %in% names(allQ[[i]])]
  }
  lst = rev(lst)
  return(lst)
  
}

# a function to find each sim's nbrs' nbr restricted to the simNbrList
find_nbrsNbrList = function(simNbrList, nbrs, debug = F) {
  nbrsNbrList = rep(list(NULL), length(nbrs))
  i = 1
  for (x in nbrs) {
    ind = sapply(simNbrList, is.element, el = x)
    xNbrs = unique(unlist(simNbrList[ind]))
    xNbrs = xNbrs[xNbrs != x] # remove x itself
    nbrsNbrList[[i]] = xNbrs
    i = i + 1
    if (debug) cat(x, "-", xNbrs, "\n")
  }
  names(nbrsNbrList) = nbrs
  return(nbrsNbrList)
}
```

## d-wrs
```{r}
d_wrs = function(G, D, debug = F) {

  # return T if G is chordal
  if (wrsgraph::is_chordal(G)) {

    if (debug) cat("chordal \n")
    return(list(wrs = 1, dag = D))

  }

  # prune all leave in G
  # since chordality is check before prunning leaves
  # the graph after pruning is guaranteed to be non-empty
  G = prune_leaves(G)
  
  # find all sim nodes in G
  sim = find_simplicial(G)

  # proceed if G has sim nodes
  if (length(sim) > 0) {
    #sim = sim[1] # remove one sim at a time
    # a matrix to store all valid edges that can be removed
    nbrsNbrMtx = matrix(0, 0, 2)
    simNbrList = list()
    if (debug) cat("sim:", sim, "\n")
    #if (debug) cat("nbrs: \n")

    # for each sim node x...
    for (x in sim) {

      # ... find its nbrs in G
      xNbrs = find_nbr(G, x)
      # ... omit deleted sim
      xNbrs = xNbrs[!xNbrs %in% sim]
      # ... store them in a list
      simNbrList[[x]] = xNbrs
      # if (debug) {
      #   cat(x, "-", xNbrs, "\n")
      # }
      # ... orient D
      D[x, xNbrs] = 0

    }

    # list unique nbrs
    nbrs = unique(unlist(simNbrList))

    # remove sim
    G = wrsgraph::subgraph(G, nodes = sim, type = "nodes")
    for (x in nbrs) {

      for (i in 1:length(simNbrList)) {
        if (is.element(x, simNbrList[[i]])) {
          if (length(simNbrList[[i]]) > 1) {

            xNbrs = simNbrList[[i]]
            xNbrs = xNbrs[xNbrs != x]
            xNbrs = xNbrs[!xNbrs %in% sim]
            nbrsNbrMtx = rbind(nbrsNbrMtx, cbind(x, xNbrs))

          }
        }
      }
    }

    # remove duplicated edge cuts
    if (length(nbrsNbrMtx) > 0) nbrsNbrMtx = remove_duplicated_edges(nbrsNbrMtx)
    if (length(nbrsNbrMtx) == 2) nbrsNbrMtx = matrix(nbrsNbrMtx, 1, 2)

    if ((debug) && (nrow(nbrsNbrMtx) > 0)) cat("#edges:", nrow(nbrsNbrMtx), "\n")

    if (nrow(nbrsNbrMtx) > 0) {

      # backup G
      backupG = G
      # backup D
      backupD = D

      #indices = c()
      #i = 1
      i = 2 ^ nrow(nbrsNbrMtx) # start from removing all edges to remove nothing
      # remove each edge combination and apply wrs_bktr()
      #while (i < (i_max + 1)) {
      #while (i > 0) {
        if (debug) cat(sim, "-", i, "\n")
        # when i=1, remove nothing
        # restore backup
        G = backupG
        D = backupD
          
        # when i > 1, remove edges
        if (i > 1) {

          # restore backup
          # G = backupG
          # D = backupD

          # compute indices
          indices = combn_ind(i, nrow(nbrsNbrMtx))
          #if (debug) cat(indices, "\n")
          #cat(indices, "\n")
          # if (nrow(nbrsNbrMtx) > 1) {
          #   # compute indices
          #   indices = combn_ind(i, nrow(nbrsNbrMtx))
          # } else {# when there is only one option
          #   indices = i
          # }

          # iteratively remove edges
          for (ind in indices) {
            from = nbrsNbrMtx[ind, 1]
            to = nbrsNbrMtx[ind, 2]
            G = wrsgraph::subgraph(G, from = from, to = to, type = "edges")
            D = wrsgraph::subgraph(D, from = from, to = to, type = "edges")
          }

        }

        # apply wrs_bktr recursively
        res = d_wrs(G, D, debug)
        if (res$wrs == 1) {

          D = res$dag
          return(list(wrs = 1, dag = D))

        }

        #i = i - 1 # decremental i because we start from full set of edges

      #}# end while
    } else {

      # apply wrs_bktr recursively
      res = d_wrs(G, D, debug)
      if (res$wrs == 1) {

        D = res$dag
        return(list(wrs = 1, dag = D))

      }
    }
  }

  return(list(wrs = 0))

}
```


## max.deg = 4
```{r}
d_wrs_deg4 = function(G, debug = F) {
  
  # return T if G is chordal
  if (wrsgraph::is_chordal(G)) {

    if (debug) cat("chordal \n")
    return(wrs = 1)

  }
  
  # prune all leave in G
  # since chordality is check before prunning leaves
  # the graph after pruning is guaranteed to be non-empty
  G = prune_leaves(G)
  
  # find all sim nodes in G
  # after prune, all simplicial nodes have at least 2 nbrs
  sim = find_simplicial(G)
  if (debug) cat(sim, "\n")
  # order sim so that those share an edge w/ cycles only are removed first
  temp = c()
  for (node in sim) {
    nbrs = names(which(G[node, ] == 1))
    comNbrs = common_nbrs(G, nbrs[1], nbrs[2])
    comNbrs = comNbrs[!comNbrs %in% sim]
    if (length(comNbrs) < 1) {
      temp = c(temp, node)
    }
  }
  temp = c(temp, sim[!sim %in% temp])
  sim = temp[1] # only sim at a time
  
  if (length(sim) > 0) {
    # 
    for (node in sim) {# check if it's a sim node

      if (node %in% colnames(G)) {

        nbrs = names(which(G[node, ] == 1))
        # if it's a K4, remove simplicial clique
        # the isolated nodes are also removed by subgraph() function
        if (length(nbrs) == 3) {
          if (debug) cat(node, "remove k4 \n")
          G = wrsgraph::subgraph(G, nodes = c(node, nbrs), type = "clique")
        } else if (length(nbrs) == 2) {
          if (debug) cat(node, "k3 \n")
          # if it's a K3
          tempG = wrsgraph::subgraph(G, nodes = node, type = "nodes")
          # find common nbrs of the two nbrs of sim node
          comNbrs = common_nbrs(tempG, nbrs[1], nbrs[2])
          # remove k3 if there is no common nbr
          if (length(comNbrs) == 0) {
            if (debug) cat("share NO edge, remove k3 \n")
            G = wrsgraph::subgraph(G, nodes = c(node, nbrs), type = "clique")
          } else if (length(comNbrs) == 2) {
            if (debug) cat("+ Cm, remove k3 \n")
            # if there are two common nbrs
            # it is either the case that the edge e is shared by 3 K3s or 
            # e is shared by a k3 and k4
            # in both cases, we just remove the sim node
            G = tempG
          } else if (length(comNbrs) == 1) {
            cNode = comNbrs
            u = common_nbrs(tempG, cNode, nbrs[1])
            v = common_nbrs(tempG, cNode, nbrs[2])
            w = length(u) + length(v)
            if (w == 4) {
              if (debug) cat("form big Tri, remove k3 \n")
              G = wrsgraph::subgraph(G, nodes = c(node, nbrs), type = "clique")
            } else if (w == 2) {
              if (debug) cat("2 k3, remove sim only \n")
              # only 2 k3 stack together, remove sim node
              G = tempG
            } else if (w == 3) {
              # there is at least 3 k3 stack one after another
              # keep testing...
              if (length(u) > length(v)) {
                comNbrs = u
                # y = v
                # yy = u
              } else {
                comNbrs = v
                # y = u
                # yy = v
              }
              cNodeNbr = comNbrs[!comNbrs %in% nbrs]
              if (length(common_nbrs(tempG, cNodeNbr, cNode)) > 1) {
                if (debug) cat("> 3 k3, remove k3 \n")
                # there is at least 4 k3 stack one after another
                # hence start removing sim clique
                G = wrsgraph::subgraph(G, nodes = c(node, nbrs), type = "clique")
              } else {
                # there are only 3 k3 
                nbrs1 = nbrs[nbrs %in% wrsgraph::find_nbr(G, cNodeNbr)]
                nbrs2 = nbrs[nbrs != nbrs1]
                tempGG = wrsgraph::subgraph(G, nodes = c(node, nbrs1, cNode), type = "nodes")
                tempGG[nbrs2, cNodeNbr] = tempGG[cNodeNbr, nbrs2] = 1
                l = calculate_cycle_length(tempGG, nbrs2, cNodeNbr, connected = F)
                if (l > 0) {
                  if (debug) cat("3 k3, remove k3 \n")
                  G = wrsgraph::subgraph(G, nodes = c(node, nbrs), type = "clique")
                } else {
                  if (debug) cat("3 k3 (middle cycle), remove sim only \n")
                  G = tempG
                }
                                
              }# end else
              
            }
            
          }
          
          
        }
        
      }# end if node is still in G
      
    }# end for each node
    
    # apply wrs_bktr recursively
    res = d_wrs_deg4(G, debug)
    if (res == 1) {

      return(wrs = 1)

    }
    
  }# end if exist sim nodes 
  
  return(wrs = 0)
  
}

```









