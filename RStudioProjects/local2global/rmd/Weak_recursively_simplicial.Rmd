---
title: "Weak recursively simplicial"
author: "Kelvin Li"
date: "21 May 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE, echo = F, eval = T)
if (.Platform$OS.type == "windows") {
  dir = "C:/Users/"
} else {
  dir = "/home/"
}
source(paste0(dir, "kl/Documents/PhDProjects/RStudioProjects/local2global/scripts/load_libraries.R"))
#library(plyr)
library(igraph)
#library(svMisc)
library(wrsgraph)
```

## randomly generating undirected graphs
```{r}
n = 1000
# no_cores = 3
# registerDoParallel(no_cores)
# res = foreach(i = 1:n, .combine="c") %dopar% {
#   G = rand_bounded_deg_graph(15, 4)
#   wrs = wrs_bktr(G, G)$wrs # wrs
#   dwrs = d_wrs_deg4(G) # qrs
#   wrs == dwrs
#   #if (wrs != dwrs) break
# }
# stopImplicitCluster()
for (i in 1:n) {
  
  G = rand_bounded_deg_graph(10, 3)
  #wrs = wrs_bktr(G, G)$wrs # wrs
  #dwrs = d_wrs_deg4(G) # qrs
  wrs = wrs_bktr(G, G)$wrs
  if (wrs != 1) break
  # g = abs(G-1)
  # diag(g) = 0
  # wrs_complement = wrs_bktr(g, g)$wrs
  # if (wrs != wrs_complement) break
}
#par(mfrow=c(1,2))
g=prune_leaves(G)
graphviz.plot(matrix2dag(g))
#graphviz.plot(matrix2dag(g))

```

```{r}
#seed
#m.deg

## plotting
g = G
G = prune_leaves(G)
#dag = readRDS("~/Documents/wrs_graph_counter_examples/0302018_1345.rds")
# g = moral(dag)
# G = dag2matrix(g)

#par(mfrow=c(1,2))
graphviz.plot(matrix2dag(G))
#graphviz.plot(matrix2dag(G), shape = "rectangle")

write.table(G,"~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx.csv", row.names = F, col.names = F)
nds = as.integer(sapply(colnames(G), gsub, pattern = "[^0-9]", replacement = ""))
write.table(nds, "~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx_nodes.csv", row.names = F, col.names = F)
```


# compare mb
```{r}
res = wrs_bktr(G, D = G, T)
dd = res$dag
dd = matrix2dag(dd)
dagl = cextend(dd)
gEdges = g$arcs
daglEdges = skeleton(dagl)$arcs
removedEdges = matrix(0, 0, 2)
for (i in 1:nrow(gEdges)) {
  if (is.na(row.match(gEdges[i, ], daglEdges))) {
    removedEdges = rbind(removedEdges, gEdges[i, ])
  }
}
removedEdges = remove_duplicated_edges(removedEdges)
if (length(removedEdges) == 2) removedEdges = matrix(removedEdges, 1, 2)
hybridl = dagl
for (i in 1:nrow(removedEdges)) hybridl = set.edge(hybridl, removedEdges[i, 1], removedEdges[i, 2])
par(mfrow=c(1,3))
graphviz.plot(dag)
graphviz.plot(g, shape = "rectangle")
graphviz.plot(dagl, shape = "rectangle")
#graphviz.plot(hybridl, highlight = list("arcs" = removedEdges), shape = "rectangle")
acyclic(dagl)
vars = bnlearn::nodes(dag)
all.equal(sapply(vars, mb, x = dagl), sapply(vars, mb, x = dag))
bnlearn::hamming(dagl, dag) # skeleton dif
bnlearn::shd(dagl, dag) # pattern dif
mean(sapply(vars, bnlearn::degree, object = dagl))
mean(sapply(vars, bnlearn::degree, object = dag))
```


```{r}
# a function to compute the total degree of a node in an undirected graph


# identify if a given set of nodes are simplicial in a graph
# names(nbrsList) must contain the given nodes
are_simplicial = function(graph, nodes) {
  
  sim = rep(0, length(nodes))
  i = 1
  for (x in nodes) {
    sim[i] = is_simplicial(graph, x)
    i = i + 1
  }
  return(sim)
  
}

# check if a graph is empty
is_empty_graph = function(graph) {
  
  empty = 0
  if (sum(graph) < 1) empty = 1
  return(empty)
  
}



# a function to list all edges
edge_set = function(graph, nodes) {
  
  m = matrix(0, ncol = 2, nrow = sum(graph[nodes, nodes]) / 2)
  k = 1
  for (i in 1:(length(nodes) - 1)) {
    for (j in (i + 1):length(nodes)) {
      m[k, ] = c(nodes[c(i, j)])
      k = k + 1
    }
  }
  return(m)
  
}

# a function to find the minimal edges cut to make a non-sim node x into a sim node in subG
# subset is a vector of nodes that must be appeared in all cliques, it could be empty
minimal_edges_cut = function(subG, x, xNbrs, subset) {
  
  # the task here is to find the maximal clique from c(removed, remained) 
  # that contains all nodes in remained
  ig = igraph::graph_from_adjacency_matrix(subG[xNbrs, xNbrs], mode = "undirected")
  # run cliques(ig, min = 3) to find all cliques w/ >= 3 nodes 
  # and idenfity the maximal clique containing remained 
  # if no such a clique then the minimal edge cut to make node sim 
  # is the set of edges b/w nodea nd removed 
  allQ = cliques(ig, min = length(subset))
  qSizes = sapply(allQ, length)
  keep = rep(1, length(allQ))
  if (length(subset) > 0) {
    for (i in 1:length(allQ)) {
      if (prod(subset %in% names(allQ[[i]])) == 0) keep[i] = 0
    }
  }
  
  maxQSize = qSizes[max(which(keep == 1))]
  maxQList = allQ[keep == 1][which(qSizes[keep == 1] == maxQSize)]
  edgesCut = rep(list(NULL), length(maxQList))
  for (i in 1:length(maxQList)) {
    edgesCut[[i]] = c(edgesCut[[i]], xNbrs[!xNbrs %in% names(maxQList[[i]])])
  }
  return(edgesCut)
  
}

# find all possible edge cut that makes x a sim node in the remaining graph
# the output is a list of edge cut, ordered from min to max # of edges
all_edges_cut = function(subG, x, xNbrs, subset) {
  
  ig = igraph::graph_from_adjacency_matrix(subG[xNbrs, xNbrs], mode = "undirected")
  allQ = cliques(ig, min = length(subset))
  keep = rep(1, length(allQ))
  if (length(subset) > 0) {
    for (i in 1:length(allQ)) {
      if (prod(subset %in% names(allQ[[i]])) == 0) keep[i] = 0
    }
  }
  allQ = allQ[keep == 1]
  lst = list()
  for (i in 1:length(allQ)) {
      lst[[i]] = xNbrs[!xNbrs %in% names(allQ[[i]])]
  }
  lst = rev(lst)
  return(lst)
  
}

# a function to find each sim's nbrs' nbr restricted to the simNbrList
find_nbrsNbrList = function(simNbrList, nbrs, debug = F) {
  nbrsNbrList = rep(list(NULL), length(nbrs))
  i = 1
  for (x in nbrs) {
    ind = sapply(simNbrList, is.element, el = x)
    xNbrs = unique(unlist(simNbrList[ind]))
    xNbrs = xNbrs[xNbrs != x] # remove x itself
    nbrsNbrList[[i]] = xNbrs
    i = i + 1
    if (debug) cat(x, "-", xNbrs, "\n")
  }
  names(nbrsNbrList) = nbrs
  return(nbrsNbrList)
}
```









