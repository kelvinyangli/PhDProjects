---
title: "Weak recursively simplicial"
author: "Kelvin Li"
date: "21 May 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE, echo = F, eval = T)
if (.Platform$OS.type == "windows") {
  dir = "C:/Users/"
} else {
  dir = "/home/"
}
source(paste0(dir, "kl/Documents/PhDProjects/RStudioProjects/local2global/scripts/load_libraries.R"))
library(plyr)
library(igraph)
library(svMisc)
```

## randomly generating undirected graphs
```{r}
repeat {
G = randAdjmtx(10, 3)
G = G + t(G)
if (!is_chordal(G)) break
}
graphviz.plot(matrix2dag(G))
#write.table(G, "~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx.csv", row.names = F, col.names = F)
nodes = colnames(G)
ndsl = sapply(nodes,strsplit,"")
nds = c()
for (i in 1:length(ndsl)) nds = c(nds, as.integer(ndsl[[i]][2]))
#write.table(nds, "~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx_nodes.csv", row.names = F, col.names = F)
```

## randomly generating wrs graphs
```{r}
n = 10000
for (i in 1:n) {
  progress(i, 10, n)
# randomly generate a w.r.s. graph
  repeat {
    #sd = randSeed()
    #set.seed(sd)
    dag = randDag(15, 5)
    g = moral(dag)
    G = dag2matrix(g)
    if (!is_chordal(G)) break
  }
  vars = colnames(G)
  if (!is_wrs(G)) {
    break
  }
}

i
```


## plotting
```{r}
# dag = readRDS("~/Documents/wrs_graph_counter_examples/0302018_1345.rds")

# repeat{
# dag = randDag(10, 3)
g = moral(dag)
G = dag2matrix(g)
# if (!is_chordal(G)) break
# }

# is_chordal(G)
# is_chordal2(G)
# is_wrs7(G)
# graph = G
# nodes = colnames(graph)
# nbrsList = lapply(nodes, find_nbr, graph = graph)
# names(nbrsList) = nodes
# (simplicialNodes = find_simplicial(graph))
par(mfrow=c(1,2))
graphviz.plot(dag)
graphviz.plot(g, shape = "rectangle")

#identify cycles in F, protect the clique that can break the cycles.
#write.table(G,"~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx.csv", row.names = F, col.names = F)
#nds = as.integer(sapply(nodes, gsub, pattern = "[^0-9]", replacement = ""))
#write.table(nds, "~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx_nodes.csv", row.names = F, col.names = F)
```

# compare mb
```{r}
dd = read.csv("~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx.csv", header = T)
row.names(dd) = colnames(dd)
dd = matrix2dag(dd)
acyclic(dd)
all.equal(sapply(nodes, mb, x = dd), sapply(nodes, mb, x = dag))
```

## functions
1. a function to find nbrs
2. a function to identify clique among vars
3. a function to test simplicity of a node
4. a function to find all simplicial nodes 
```{r}
# i - index
# q - separation
# n - total iteration
progress = function(i, q, n) {
  if (i == 1) {
    print(i)
  } else if (((i %% q) == 0) && (i < n)) {
    print(i)
  } else if (i == n) {
    print("Done!")
  } 
}

# a function to remove duplicated rows in a data.frame/matrix
remove_duplicated_edges = function(x) {
  
  for (i in 1:nrow(x)) x[i, ] = x[i, ][order(x[i, ])]
  if (is.data.frame(x)) {
    x = x[!duplicated.data.frame(x), ]  
  } else if (is.matrix(x)) {
    x = x[!duplicated.matrix(x), ]
  }
  row.names(x) = c()
  return(x)
  
}

# graph is an adj mtx with col and row names equal to vars
# the outputs are var names 
find_nbr = function(graph, node) names(which(graph[node, ] == 1))

# a function to compute the total degree of a node in an undirected graph
degree = function(graph, node) {
  
  nbrs = find_nbr(graph, node)
  return(length(nbrs))
  
}

# identify if the given nodes form a clique
is_clique = function(graph, nodes) {
  
  clq = 1
  for (i in 1:(length(nodes) - 1)) {
    
    if (clq == 0) break
    x = nodes[i]
    for (j in (i + 1):length(nodes)) {
      
      y = nodes[j]
      if (graph[x, y] != 1) {
        clq = 0
        break
      }
      
    }
    
  }
  return(clq)
}

# identify if a given node is simplicial in a graph
is_simplicial = function(graph, node) {
  
  nbrs = names(which(graph[node, ] == 1))
  if (length(nbrs) < 2) {
    clq = 1
  } else {
    clq = is_clique(graph, nbrs)
  }
  return(clq)
  
}

# identify if a given set of nodes are simplicial in a graph
# names(nbrsList) must contain the given nodes
are_simplicial = function(graph, nodes) {
  
  sim = rep(0, length(nodes))
  i = 1
  for (x in nodes) {
    sim[i] = is_simplicial(graph, x)
    i = i + 1
  }
  return(sim)
  
}

# find all simplicial nodes in a graph
# treat isolated node as a simplicial node for programming convenience
# the output is a vector of simplicial nodes in a graph, ordered by degree ascending
find_simplicial = function(graph) {
  
  nodes = colnames(graph)
  sim = c()
  degrees = c()
  for (x in nodes) {
    nbrs = names(which(graph[x, ] == 1))
    if (length(nbrs) < 1) {
      sim = c(sim, x)
      degrees = c(degrees, 0)
    } else {
      if (is_simplicial(graph, x)) {
        sim = c(sim, x)
        degrees = c(degrees, length(nbrs))
      }
    }
  }
  if (length(sim) > 1) sim = sim[order(degrees)]
  return(sim)
  
}

# get subgraph by removing a node x
subgraph = function(graph, nodes = NULL, from = NULL, to = NULL, 
                    type = c("nodes", "edges")) {
  
  if (type == "nodes") {
    nodeIndex = which(colnames(graph) %in% nodes)  
    graph = graph[-nodeIndex, -nodeIndex]
  } else if (type == "edges") {
    if (is.null(nodes)) {
      for (x in from) {
        for (y in to) {
          graph[x, y] = graph[y, x] = 0
        }
      }
    } else {
      for (x in nodes) {
        for (y in nodes[nodes != x]) {
          graph[x, y] = 0
        }
      }
    }
    
  }
  return(graph)
  
}

# check if a graph is empty
is_empty_graph = function(graph) {
  
  empty = 0
  if (sum(graph) < 1) empty = 1
  return(empty)
  
}

# check if a graph (in adj mtx format) is chordal using igraph::is_chordal
is_chordal = function(graph) {
  
  ig = igraph::graph_from_adjacency_matrix(graph, mode = "undirected")
  return(as.numeric(igraph::is_chordal(ig)$chordal))
  
}

# a function to find common nbrs of two nodes 
common_nbrs = function(graph, x, y) {
  
  xNbrs = names(which(graph[x, ] == 1))
  yNbrs = names(which(graph[y, ] == 1))
  return(intersect(xNbrs, yNbrs))
  
}


# a function to list all edges
edge_set = function(graph, nodes) {
  
  m = matrix(0, ncol = 2, nrow = sum(graph[nodes, nodes]) / 2)
  k = 1
  for (i in 1:(length(nodes) - 1)) {
    for (j in (i + 1):length(nodes)) {
      m[k, ] = c(nodes[c(i, j)])
      k = k + 1
    }
  }
  return(m)
  
}

# a function to find the minimal edges cut to make a non-sim node x into a sim node in subG
# subset is a vector of nodes that must be appeared in all cliques, it could be empty
minimal_edges_cut = function(subG, x, xNbrs, subset) {
  
  # the task here is to find the maximal clique from c(removed, remained) 
  # that contains all nodes in remained
  ig = igraph::graph_from_adjacency_matrix(subG[xNbrs, xNbrs], mode = "undirected")
  # run cliques(ig, min = 3) to find all cliques w/ >= 3 nodes 
  # and idenfity the maximal clique containing remained 
  # if no such a clique then the minimal edge cut to make node sim 
  # is the set of edges b/w nodea nd removed 
  allQ = cliques(ig, min = length(subset))
  qSizes = sapply(allQ, length)
  keep = rep(1, length(allQ))
  if (length(subset) > 0) {
    for (i in 1:length(allQ)) {
      if (prod(subset %in% names(allQ[[i]])) == 0) keep[i] = 0
    }
  }
  
  maxQSize = qSizes[max(which(keep == 1))]
  maxQList = allQ[keep == 1][which(qSizes[keep == 1] == maxQSize)]
  edgesCut = rep(list(NULL), length(maxQList))
  for (i in 1:length(maxQList)) {
    edgesCut[[i]] = c(edgesCut[[i]], xNbrs[!xNbrs %in% names(maxQList[[i]])])
  }
  return(edgesCut)
  
}


# find all possible edge cut that makes x a sim node in the remaining graph
# the output is a list of edge cut, ordered from min to max # of edges
all_edges_cut = function(subG, x, xNbrs, subset) {
  
  ig = igraph::graph_from_adjacency_matrix(subG[xNbrs, xNbrs], mode = "undirected")
  allQ = cliques(ig, min = length(subset))
  keep = rep(1, length(allQ))
  if (length(subset) > 0) {
    for (i in 1:length(allQ)) {
      if (prod(subset %in% names(allQ[[i]])) == 0) keep[i] = 0
    }
  }
  allQ = allQ[keep == 1]
  lst = list()
  for (i in 1:length(allQ)) {
      lst[[i]] = xNbrs[!xNbrs %in% names(allQ[[i]])]
  }
  lst = rev(lst)
  return(lst)
  
}

# a function to find each sim's nbrs' nbr restricted to the simNbrList
find_nbrsNbrList = function(simNbrList, nbrs, debug = F) {
  nbrsNbrList = rep(list(NULL), length(nbrs))
  i = 1
  for (x in nbrs) {
    ind = sapply(simNbrList, is.element, el = x)
    xNbrs = unique(unlist(simNbrList[ind]))
    xNbrs = xNbrs[xNbrs != x] # remove x itself
    nbrsNbrList[[i]] = xNbrs
    i = i + 1
    if (debug) cat(x, "-", xNbrs, "\n")
  }
  names(nbrsNbrList) = nbrs
  return(nbrsNbrList)
}


# i, n > 1
# n = nrow(nbrsNbrMtx)
# i = index, option i
combn_ind = function(i, n) {
  ss = 0 
  for (j in 0:n) {
    ss = ss + choose(n, j)
    if (ss >= i) break
  }
  ind = i - (ss - choose(n, j))
  return(combn(1:n, j)[, ind])
}



find_ind = function(n, m, totalNum) {
  k = tail(which(n > totalNum), 1)
  ind = n - totalNum[k]
  cat(k, ind, "\n")
  return(combn(1:m, k)[, ind])
}
```


## 2nd version
```{r}
# check if a graph is wrs or not 
# steps:
# 4. find all simplicial nodes in g, sub_g := g
# 5.1. for each simplicial node x, sub_g := sub_g[X-x]
# 5.2*. find simplicial nodes in nbrs(x) in sub_g
# 6*. remove edge y-z if: 
# a. none of y and z is a simplicial node in either g or sub_g and,
# b. y-z doesn't belong to the neighbouring clique of a simplicial node in g or sub_g.  
# 7*. g = sub_g, go back to step 5.1 and repeat for another simplicial node in g, 
# 8. once all simplicial nodes in g have been considered, g := sub_g
# 9. go back to step 4
# termination criteria is not correct!
is_wrs = function(graph) {
  
  repeat {
    
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      
      wrs = 1
      break
      
    }
    
    # if the current graph is non-chordal, continue...
    # step 4:
    nodes = colnames(graph)
    nbrsList = lapply(nodes, find_nbr, graph = graph)
    names(nbrsList) = nodes
    simplicialNodes = find_simplicial(graph, nbrsList, nodes)
    subG = graph
    if (length(simplicialNodes) > 0) {
      
      # step 5.1:
      for (x in simplicialNodes) {# for each sim node x in graph
        
        subG = subgraph(subG, x)
        xNbrs = nbrsList[[which(nodes == x)]] 
        xNbrs = xNbrs[xNbrs %in% colnames(subG)]  # remove deleted nodes from xNbrs
        nonSim = c()
        
        # only check if x's nbrs are simplicial in subG if it has more than 1 nbr
        if (length(xNbrs) > 1) {
          
          # step 5.2: check simplicial of nbrs(x) in subG
          for (y in xNbrs) {# for each y in nbrs(x)
            yNbrs = nbrsList[[which(nodes == y)]]
            yNbrs = yNbrs[yNbrs != x] # remove x because x isn't in tempG
            yNbrs = yNbrs[yNbrs %in% colnames(subG)] # remove deleted nodes from yNbrs
            # check if y is a simplicial node in tempG
            if (!y %in% simplicialNodes) {# if y is non-sim in G...
              # ... and y is non-sim in subG, record it
              if (!is_simplicial(subG, y, yNbrs)) nonSim = c(nonSim, y)  
            }
          } # end of step 5.2
        
          # step 6:
          # remove edge y-z b/w non-simplicial nbrs in tempG if 
          # a. none of y and z is a simplicial node in either g or sub_g (checked in step 5.2) and,
          # b. y, z are not nbrs of another simplicial node in g or subG
          if (length(nonSim) > 1) {# only if there are at leat 2 non-sim nodes
            
            # find mutual nbrs b/w each pair of non-sim nodes in nbrs(x)
            for (i in 1:(length(nonSim) - 1)) {
              for (j in (i + 1):length(nonSim)) {
                
                safeToRemove = 1
                # check if their nbrs are sim nodes in either G or subG
                mutualNbrs = common_nbrs(subG, nonSim[i], nonSim[j]) 
                mutualNbrs = mutualNbrs[mutualNbrs != x] # remove x 
                mutualNbrs = mutualNbrs[mutualNbrs %in% colnames(subG)] # remove deleted nodes from mutualNbrs
                for (k in mutualNbrs) {
                  if (k %in% simplicialNodes) {# if k is sim in g
                    safeToRemove = 0
                    break
                  }
                  kInd = which(nodes == k)
                  kNbrs = nbrsList[[kInd]]
                  kNbrs = kNbrs[kNbrs %in% colnames(subG)]
                  if (is_simplicial(subG, k, kNbrs)) {# if k is sim in subG
                    safeToRemove = 0
                    break
                  }
                }# end for checking mutualNbrs
                
                if (safeToRemove) subG[nonSim[i], nonSim[j]] = subG[nonSim[j], nonSim[i]] = 0
                
              }
            }
            
          } # end of step 6
          
        } # end of step 5.2
        
      }# end of step 5.1 for each sim node x
      
      graph = subG # update graph
    
    } else if (length(simplicialNodes) < 1) {
      
      # if the current is non-chordal and has no simplicial node, then it isn't wrs
      wrs = 0
      break 
      
    }
    
  } # end repeat
  
  return(wrs)
  
}
```

# 3rd version (currently used)
```{r}
# check if a graph is wrs or not 
# steps:
# 4. find all simplicial nodes in g, sub_g := g
# 5.1. for each simplicial node x, sub_g := sub_g[X-x]
# 5.2*. find simplicial nodes in nbrs(x) in sub_g
# 6*. remove edge y-z if: 
# a. none of y and z is a simplicial node in either g or sub_g and,
# b. y-z doesn't belong to the neighbouring clique of a simplicial node in g or sub_g.  
# 7*. g = sub_g, go back to step 5.1 and repeat for another simplicial node in g, 
# 8. once all simplicial nodes in g have been considered, g := sub_g
# 9. go back to step 4
# termination criteria is not correct!
# 
# remove as fewer edges as possible
# by that i mean if delete a node x and its edges introduce another sim node y (y in nbrs(x)) in the subgraph, will y still be a sim node in subgraph if only remove partial edges of x
is_wrs3 = function(graph) {
  
  repeat {
    
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      
      wrs = 1
      break
      
    }
    
    # if the current graph is non-chordal, continue...
    # step 4:
    nodes = colnames(graph)
    nbrsList = lapply(nodes, find_nbr, graph = graph)
    names(nbrsList) = nodes
    simplicialNodes = find_simplicial(graph, nbrsList, nodes)
    if (length(simplicialNodes) > 0) {
      
      # order simplicial nodes by node degree ascending
      degrees = sapply(simplicialNodes, degree, graph = graph)
      simplicialNodes = simplicialNodes[order(degrees)]
      # step 5.1:
      #for (x in simplicialNodes) {# for each sim node x in graph
        x = simplicialNodes[1] # take the 1st simplicial node
        subG = subgraph(graph, x)
        xNbrs = nbrsList[[which(nodes == x)]] 
        #xNbrs = xNbrs[xNbrs %in% colnames(subG)]  # remove deleted nodes from xNbrs
        nonSim = c()
        
        # only check if x's nbrs are simplicial in subG if it has more than 1 nbr
        if (length(xNbrs) > 1) {
          
          # step 5.2: check simplicial of nbrs(x) in subG
          for (y in xNbrs) {# for each y in nbrs(x)
            yNbrs = nbrsList[[which(nodes == y)]]
            yNbrs = yNbrs[yNbrs != x] # remove x because x isn't in tempG
            #yNbrs = yNbrs[yNbrs %in% colnames(subG)] # remove deleted nodes from yNbrs
            # check if y is a simplicial node in tempG
            if (!y %in% simplicialNodes) {# if y is non-sim in G...
              # ... and y is non-sim in subG, record it
              if (!is_simplicial(subG, y, yNbrs)) nonSim = c(nonSim, y)  
            }
          } # end of step 5.2
        
          # step 6:
          # remove edge y-z b/w non-simplicial nbrs in tempG if 
          # a. none of y and z is a simplicial node in either g or sub_g (checked in step 5.2) and,
          # b. y, z are not nbrs of another simplicial node in g or subG
          if (length(nonSim) > 1) {# only if there are at leat 2 non-sim nodes
            
            # find mutual nbrs b/w each pair of non-sim nodes in nbrs(x)
            for (i in 1:(length(nonSim) - 1)) {
              for (j in (i + 1):length(nonSim)) {
                
                safeToRemove = 1
                # check if their nbrs are sim nodes in either G or subG
                mutualNbrs = common_nbrs(subG, nonSim[i], nonSim[j]) 
                mutualNbrs = mutualNbrs[mutualNbrs != x] # remove x 
                #mutualNbrs = mutualNbrs[mutualNbrs %in% colnames(subG)] # remove deleted nodes from mutualNbrs
                for (k in mutualNbrs) {
                  if (k %in% simplicialNodes) {# if k is sim in g
                    safeToRemove = 0
                    break
                  }
                  kInd = which(nodes == k)
                  kNbrs = nbrsList[[kInd]]
                  kNbrs = kNbrs[kNbrs != x]
                  #kNbrs = kNbrs[kNbrs %in% colnames(subG)]
                  if (is_simplicial(subG, k, kNbrs)) {# if k is sim in subG
                    safeToRemove = 0
                    break
                  }
                }# end for checking mutualNbrs
                
                if (safeToRemove) subG[nonSim[i], nonSim[j]] = subG[nonSim[j], nonSim[i]] = 0
                
              }
            }
            
          } # end of step 6
          
        } # end of step 5.2
        
      #}# end of step 5.1 for each sim node x
      
      graph = subG # update graph
    
    } else if (length(simplicialNodes) < 1) {
      
      # if the current is non-chordal and has no simplicial node, then it isn't wrs
      wrs = 0
      break 
      
    }
    
  } # end repeat
  
  return(wrs)
  
}
```

# 4th version
```{r}
# check if a graph is wrs or not 
# steps:
# 4. find all simplicial nodes in g, sub_g := g
# 5.1. for each simplicial node x, sub_g := sub_g[X-x]
# 5.2*. find simplicial nodes in nbrs(x) in sub_g
# 6*. remove edge y-z if there is no z != x s.t. xyz forms a 3-clique 
# 7*. g = sub_g, go back to step 5.1 and repeat for another simplicial node in g, 
# 8. once all simplicial nodes in g have been considered, g := sub_g
# 9. go back to step 4
# termination criteria is not correct!
# 
# remove as fewer edges as possible
# by that i mean if delete a node x and its edges introduce another sim node y (y in nbrs(x)) in the subgraph, will y still be a sim node in subgraph if only remove partial edges of x
is_wrs4 = function(graph) {
  
  repeat {
    
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      
      wrs = 1
      break
      
    }
    
    # if the current graph is non-chordal, continue...
    # step 4:
    nodes = colnames(graph)
    nbrsList = lapply(nodes, find_nbr, graph = graph)
    names(nbrsList) = nodes
    simplicialNodes = find_simplicial(graph, nbrsList, nodes)
    if (length(simplicialNodes) > 0) {
      
      # order simplicial nodes by node degree ascending
      degrees = sapply(simplicialNodes, degree, graph = graph)
      simplicialNodes = simplicialNodes[order(degrees)]
      # step 5.1:
      #for (x in simplicialNodes) {# for each sim node x in graph
        x = simplicialNodes[1] # take the 1st simplicial node
        subG = subgraph(graph, x)
        
        xNbrs = nbrsList[[which(nodes == x)]]
        if (length(xNbrs) > 1) {
          
          # sim = c()
          # # step 5.2: check simplicial of nbrs(x) in subG
          # for (y in xNbrs) {# for each y in nbrs(x)
          #   yNbrs = nbrsList[[which(nodes == y)]]
          #   yNbrs = yNbrs[yNbrs != x] # remove x because x isn't in tempG
          #   #yNbrs = yNbrs[yNbrs %in% colnames(subG)] # remove deleted nodes from yNbrs
          #   # check if y is a simplicial node in tempG
          #   if (!y %in% simplicialNodes) {# if y is non-sim in G...
          #     # ... and y is sim in subG, record it
          #     if (is_simplicial(subG, y, yNbrs)) sim = c(sim, y)  
          #   }
          # } # end of step 5.2
          #
          # if (length(sim) + length(simplicialNodes) < 2) {# if no sim node in subG
            m = matrix(0, choose(length(xNbrs), 2), 3)
            mInd = 1  
            for (i in 1:(length(xNbrs) - 1)) {
              y = xNbrs[i]
              ySImInSubG = is_simplicial(subG, y, find_nbr(subG, y))
              for (j in (i + 1):length(xNbrs)) {
                z = xNbrs[j]
                tempG = subG 
                tempG[y, z] = tempG[z, y] = 0
                ySimInTempG = is_simplicial(tempG, y, find_nbr(tempG, y))
                zSimInSubG = is_simplicial(subG, z, find_nbr(subG, z))
                zSimInTempG = is_simplicial(tempG, z, find_nbr(tempG, z))
                nNewSim = ySimInTempG + zSimInTempG - ySImInSubG - zSimInSubG 
                m[mInd, ] = c(y, z, nNewSim)
                mInd = mInd + 1
              }
            }
            if (max(as.numeric(m[, 3])) > 0) {
              maxInd = which.max(as.numeric(m[, 3]))
              y = m[maxInd, 1]
              z = m[maxInd, 2]
              subG[y, z] = subG[z, y] = 0
            }
          # } else {# if there is sim node in subG
          #   for (i in 1:(length(xNbrs) - 1)) {
          #     y = xNbrs[i]
          #     #yInd = which(nodes == y)
          #     for (j in (i + 1):length(xNbrs)) {
          #       z = xNbrs[j]
          #       #zInd = which(nodes == z)
          #       mutualNbrs = common_nbrs(subG, y, z)
          #       mutualNbrs = mutualNbrs[mutualNbrs != x] 
          #       mutualNbrs = mutualNbrs[!mutualNbrs %in% xNbrs]  
          #       if (length(mutualNbrs) < 1) subG[y, z] = subG[z, y] = 0
          #     }
          #   }
          # }
        }
      graph = subG # update graph
    
    } else if (length(simplicialNodes) < 1) {
      
      # if the current is non-chordal and has no simplicial node, then it isn't wrs
      wrs = 0
      break 
      
    }
    
  } # end repeat
  
  return(wrs)
  
}
```


## 5th version

```{r}
# check if a graph is wrs or not 
# steps:
# 4. find all simplicial nodes in g
# 5.0 order simplicial nodes by degree ascending
# 5.1. for simplicial node x that has the smallest degree, sub_g := sub_g[X-x]
# 5.2. check if nbrs(x) are simplcial nodes in sub_g
# 6. remove edge e = y-z if the removal of e change y, z from non-sim to sim
# i.e. if none or one of y and z is a sim before removing e but more are sim after removing
# 7. g = sub_g, go back to step 4
# stop: if the remaining graph is non-chordal and has no simplicial node
# new observation**: combination of edge removal from multiple simplicial nodes could result in more sim nodes, when non single node edge removal produces sim nodes!!!
is_wrs5 = function(graph, debug = F) {
  
  repeat {
    
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      
      wrs = 1
      break
      
    }
    
    # if the current graph is non-chordal, continue...
    # step 4:
    nodes = colnames(graph)
    nbrsList = lapply(nodes, find_nbr, graph = graph)
    names(nbrsList) = nodes
    simplicialNodes = find_simplicial(graph)
    if (length(simplicialNodes) > 0) {
  
      # step 5.1: find the node x w/ the smallest degree
      x = simplicialNodes[1]
      if (debug) cat("sim node:", x, "\n")
      subG = subgraph(graph, x, "nodes")
      xNbrs = nbrsList[[x]] 
      if (debug) cat("nbrs:", xNbrs, "\n")
      if (length(xNbrs) > 1) {
        
        # step 5.2: check simplicial of nbrs(x) in subG 
        xNbrsSimInSubG = are_simplicial(subG, xNbrs)
        
        # step 6: remove edge e = y-z if the removal of e change y, z from non-sim to sim
        # i.e. if none or one of y and z is a sim before removing e but more are sim after removing
        if (sum(xNbrsSimInSubG) < length(xNbrs)) {
          # remove all edges to check how many new sim could be produced
          tempG = subgraph(subG, xNbrs, "edges")
          xNbrsSimInTempG = are_simplicial(tempG, xNbrs)
          # if new sim nodes are introduced...
          if (sum(xNbrsSimInTempG) > sum(xNbrsSimInSubG)) {
            # ... remove corresponding edges
            newSim = xNbrs[which(xNbrsSimInTempG > xNbrsSimInSubG)]
            edges = edge_set(subG, xNbrs)
            #############################################
            for (i in 1:nrow(edges)) {
              tempGG = tempG
              tempGG[edges[i, 1], edges[i, 2]] = tempGG[edges[i, 2], edges[i, 1]] = 1
              if (prod(are_simplicial(tempGG, newSim))) {# if yes, add the edge
                tempG = tempGG
              }
            }
            if (debug) cat("remove edges: \n")
            if (debug) print(subG - tempG)
            subG = tempG
            # ... but only remove minimal edge set
            # toDeleteEdges = minimal_edge_removal(subG, xNbrs, newSim)
            # for (i in 1:nrow(toDeleteEdges)) {
            #   subG[toDeleteEdges[i, 1], toDeleteEdges[i, 2]] = 
            #     subG[toDeleteEdges[i, 2], toDeleteEdges[i, 1]] = 0
            # }
            # for (p in xNbrs) {
            #   for (q in xNbrs[xNbrs != p]) {
            #     if ((p %in% newSim) || (q %in% newSim)) subG[p, q] = 0 
            #   }
            # }# end for p
            #############################################
            
          }
        }
          
      } # end of step 5.2
    
      # step 7:
      graph = subG # update graph
      if (debug) cat("----------------------------- \n")
    } else if (length(simplicialNodes) < 1) {
      
      # if the current is non-chordal and has no simplicial node, then it isn't wrs
      wrs = 0
      break 
      
    }
    
  } # end repeat
  
  return(wrs)
  
}
```

# 6th version
```{r}
# steps:
# 3. find nbrsList for all nodes
# 4. find all sim nodes in G
# 5. remove all sim nodes simultaneously and update 
#    subG = G[X - sim]
# 7. list all nbrs of the removed sims
# 8. for each nbr y, find the minimal edge set, removing which y becomes sim 
#    the edge set could be empty, which implies either y is a sim or no way to be a sim
#    for some node, there maybe more than one set of edges to make it a sim
#    in the end we want a collection of edges to be as small as possible 
#    but keep all nodes connected (i.e., no isolated nodes) 
# 9. remove the minimal edge sets,
#    G = subG and back to step 4
is_wrs6 = function(graph, debug = F) {
  
  repeat {
    
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      wrs = 1
      break
    }
    
    # if the current graph is non-chordal, continue...
    # step 3: find nbrsList for all nodes
    # nodes = colnames(graph)
    # nbrsList = lapply(nodes, find_nbr, graph = graph)
    # names(nbrsList) = nodes
    # step 4: find all sim nodes in graph
    simInG = find_simplicial(graph)
    
    if (length(simInG) > 0) {
  
      if (debug) cat("sim nodes:", simInG, "\n")
      
      # step 5: remove all sim nodes simultaneously 
      subG = subgraph(graph, simInG, "nodes") # update subG
      
      # step 6.1: list all nbrs in G of the removed sim nodes
      simNbrsList = lapply(simInG, find_nbr, graph = graph)
      names(simNbrsList) = simInG
      
      # step 6.2: for each nbr y, find its nbr in subG from simNbrsList
      selectedNodes = unique(unlist(simNbrsList))
      # remove those sim nodes that have been removed
      selectedNodes = selectedNodes[!selectedNodes %in% simInG]
      selectedNodesNbrsList = rep(list(NULL), length(selectedNodes))
      for (i in 1:length(selectedNodes)) {
        x = selectedNodes[i]
        for (j in 1:length(simNbrsList)) {
          if ((x %in% simNbrsList[[j]]) && (length(simNbrsList[[j]]) > 1)) {
            xPartialNbrs = simNbrsList[[j]] 
            xPartialNbrs = xPartialNbrs[xPartialNbrs != x] # remove x
            # remove all sim nodes that have been removed 
            xPartialNbrs = xPartialNbrs[!xPartialNbrs %in% simInG] 
            selectedNodesNbrsList[[i]] = 
              c(selectedNodesNbrsList[[i]], xPartialNbrs)
          }
        }
      }
      selectedNodesNbrsList = lapply(selectedNodesNbrsList, unique)
      names(selectedNodesNbrsList) = selectedNodes
      #l = c()
      totalEdgesCut = data.frame()
      # step 7.1: for each non-sim node y in selectedNodes, check if it has the potential 
      # to be a sim by removing all its nbrs in selectedNodesNbrsList
      for (x in selectedNodes) {
        if ((length(selectedNodesNbrsList[[x]]) > 0) && (!is_simplicial(subG, x))) {
          # remove all its nbrs from selectedNodesNbrsList
          tempG = subG
          tempG[x, selectedNodesNbrsList[[x]]] = tempG[selectedNodesNbrsList[[x]], x] = 0
          if (is_simplicial(tempG, x)) {
            xTotalNbrs = names(which(subG[x, ] == 1))
            xOtherNbrs = xTotalNbrs[!xTotalNbrs %in% selectedNodesNbrsList[[x]]]
            eCut = minimal_edges_cut(subG, x, xTotalNbrs, xOtherNbrs)
            
            # there maybe cases with more than one set of edges cut for a node
            # in this case select the set that makes the entire edges cut set minimal
            # if no unique solution, then pick the 1st set
            # if only one set then proceed...
            #if (length(eCut) == 1) {
              #cat(length(eCut), "\n")
              for (y in unlist(eCut[[1]])) {
                e = c(x, y)
                e = e[order(e)]
                # only bind non-existence edges
                if (is.na(row.match(e, totalEdgesCut))) {
                  totalEdgesCut = rbind(totalEdgesCut, e, stringsAsFactors = F)  
                }
              }
            #} else {# otherwise...
              
              #cat("error!")
            #}
          }
        }
      }
      
      # step 7.2: remove edges from subG
      if (nrow(totalEdgesCut) > 0) {
        for (i in 1:nrow(totalEdgesCut)) {
          subG[totalEdgesCut[i, 1], totalEdgesCut[i, 2]] = 
            subG[totalEdgesCut[i, 2], totalEdgesCut[i, 1]] = 0
          if (is_chordal(subG)) {
            wrs = 1
            break
          }
        }
      }
      
      # step 8:
      graph = subG # update graph
      
    } else {# if graph is non-chordal and has no sim nodes 
      
      wrs = 0
      break 
      
    }
    
  } # end repeat
  
  return(wrs)
  
}
```

# 7th version
```{r}
# steps:
# 3. find nbrsList for all nodes
# 4. find all sim nodes in G
# 5. remove all sim nodes simultaneously and update 
#    subG = G[X - sim]
# 7. list all nbrs of the removed sims
# 8. for each nbr y, find the minimal edge set, removing which y becomes sim 
#    the edge set could be empty, which implies either y is a sim or no way to be a sim
#    for some node, there maybe more than one set of edges to make it a sim
#    in the end we want a collection of edges to be as small as possible 
#    but keep all nodes connected (i.e., no isolated nodes) 
# 9. remove the minimal edge sets,
#    G = subG and back to step 4
#    
#    Notice*: ver7 still won't work on large dags, I suspect this is because each time when deleting nbring edges, ver7 deletes as minimum edges as possible. But if an edge is in the cachedEdges (which means safe to be removed), it should also be removed. 
#    
#    
#    Try this: in ver7, when trying to make a node x sim, we find the largest clique and delete as minimum number of edges as possible. But we could try to find all cliques and keep the one that could make one of the clique node sim in the next step. 
is_wrs7 = function(graph, debug = F) {
  
  # cach all edges b/w nbrs of sim nodes
  # exist duplicated edges, fixed it!!!
  cachedEdges = data.frame(stringsAsFactors = F)
  repeat {
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      wrs = 1
      break
    }
    
    simInG = find_simplicial(graph)
    if (debug) cat("sim:", simInG, "\n")
    if (length(simInG) > 0) {
      subG = subgraph(graph, nodes = simInG, type = "nodes") # update subG
      simNbrsList = lapply(simInG, find_nbr, graph = graph)
      names(simNbrsList) = simInG
      if (debug) {
        for (x in simInG) {
          cat(x, "-", simNbrsList[[x]], "\n")
        }
      }
      selectedNodes = unique(unlist(simNbrsList))
      selectedNodes = selectedNodes[!selectedNodes %in% simInG]
      selectedNodesNbrsList = rep(list(NULL), length(selectedNodes))
      
      for (i in 1:length(selectedNodes)) {
        x = selectedNodes[i]
        for (j in 1:length(simNbrsList)) {
          if ((x %in% simNbrsList[[j]]) && (length(simNbrsList[[j]]) > 1)) {
            xPartialNbrs = simNbrsList[[j]] 
            xPartialNbrs = xPartialNbrs[xPartialNbrs != x] # remove x
            # remove all sim nodes that have been removed 
            xPartialNbrs = xPartialNbrs[!xPartialNbrs %in% simInG] 
            if (length(xPartialNbrs) > 0) {
              selectedNodesNbrsList[[i]] = c(selectedNodesNbrsList[[i]], xPartialNbrs)
            }
          }
        }
      }
      if (debug) cat("+++++ \n")
      selectedNodesNbrsList = lapply(selectedNodesNbrsList, unique)
      names(selectedNodesNbrsList) = selectedNodes
      if (debug) {
        for (x in selectedNodes) cat(x, "-", selectedNodesNbrsList[[x]], "\n")
      }
      
      #cachedEdgesTemp = data.frame(stringsAsFactors = F)
      for (x in selectedNodes) {
        for (y in selectedNodesNbrsList[[x]]) {
          e = as.data.frame(t(c(x, y)))
          if (is.na(row.match(e, cachedEdges)) && is.na(row.match(rev(e), cachedEdges))) {
            cachedEdges = rbind(cachedEdges, e)
          }
        }
      }
      #cachedEdgesTemp = remove_df_duplicated_with_no_order(cachedEdgesTemp)
      #cachedEdges = rbind(cachedEdges, cachedEdgesTemp)
      #cachedEdges = remove_df_duplicated_with_no_order(cachedEdges)
      # remove minimal edges cut one by one
    
      if (debug) cat("+++++ \n")
      # step 7.1: for each non-sim node y in selectedNodes, check if it has the potential 
      # to be a sim by removing all its nbrs in selectedNodesNbrsList
      for (x in selectedNodes) {
        if (is_simplicial(subG, x)) {
          if (debug) cat(x, "- y \n")
        } else {
          
          if (x %in% c(t(cachedEdges))) {
            # remove all its nbrs from selectedNodesNbrsList
            tempG = subG
            # a vector of nodes that have formed a clique with x so far
            Y = selectedNodesNbrsList[[x]]
            Y = c(Y, c(t(cachedEdges[apply(cachedEdges, 1, is.element, el = x), ])))
            Y = unique(Y)
            Y = Y[Y != x]
            Y = Y[Y %in% colnames(tempG)]
            tempG[x, Y] = tempG[Y, x] = 0
            if (is_simplicial(tempG, x)) {
              
              xTotalNbrs = names(which(subG[x, ] == 1))
              xOtherNbrs = xTotalNbrs[!xTotalNbrs %in% Y]
              eCut = minimal_edges_cut(subG, x, xTotalNbrs, xOtherNbrs)
              if (length(eCut) > 1) {
                if (debug) cat(length(eCut), " opts:", unlist(eCut[-which.max(sapply(eCut, length))]), "\n")
                eCut = eCut[which.max(sapply(eCut, length))]
                #eCut = eCut[2]
              }
              xNbrsToBeDeleted = unlist(eCut)
              # there maybe cases with more than one set of edges cut for a node
              # in this case select the set that makes the entire edges cut set minimal
              # if no unique solution, then pick the 1st set
              # if only one set then proceed...
              #if (length(eCut) == 1) {
  
              if (debug) cat(x, "-", xNbrsToBeDeleted, "-", xOtherNbrs, "\n")
              for (y in xNbrsToBeDeleted) {
                subG[x, y] = subG[y, x] = 0
                e = c(x, y)
                e = e[order(e)]
                ind = row.match(e, cachedEdges)
                if (!is.na(ind)) {
                  cachedEdges = cachedEdges[-ind, ]
                }
              }
            }
              #} else {# otherwise...
                
                #cat("error!")
              #}
          } 
        }
      }
      
      
      # step 8:
      graph = subG # update graph
      
    } else {# if graph is non-chordal and has no sim nodes 
      
      wrs = 0
      break 
      
    }
    if (debug) cat("----------------------- \n")
  } # end repeat
  
  return(wrs)
  
}
```

## Thoughts: 
1. sim nodes in step 1 contain leaves. 
2. if x is a sim node in step 1 and y is in nb(x), remove x doesn't necessary make y a sim node in step 2, because y could have parents and spouses, which are not fully connect to each other after moralization. 
3. But if all edges b/w nb(x) are also removed, the remaining nodes are those that connect w/ y, but not with x. If these remaining nodes could form a clique, then y could be a sim node by removing all nb(x) edges. But there are chances that useful edges are removed. 
4. but even if all nb(x) edges are removed, the remaining nodes of y may not form a clique. However, the idea is to eleminate nodes from bottom to top, so children are removed first,                              

## Backtracking search
```{r}
is_wrs = function(G, debug = F) {
  
  if (is_chordal(G)) {
    if (debug) cat("chordal \n")
    return(1)
  }
  
  sim = find_simplicial(G)
  
  
  if (length(sim) > 0) {
    
    nbrsNbrMtx = matrix(0, 0, 2)
    simNbrList = list()
    if (debug) cat("sim:", sim, "\n")
    if (debug) cat("nbrs: \n")
    
    # find sim's nbrs
    for (x in sim) {
      xNbrs = find_nbr(G, x)
      xNbrs = xNbrs[!xNbrs %in% sim]
      simNbrList[[x]] = xNbrs
      if (debug) {
        cat(x, "-", xNbrs, "\n")
      }
    }
    
    # list unique nbrs
    nbrs = unique(unlist(simNbrList))
    
    # omit deleted sim
    nbrs = nbrs[!nbrs %in% sim]
    
    if (debug) cat("re-arrange:", nbrs, "\n")
    
    # remove sim 
    G = subgraph(G, nodes = sim, type = "nodes")
    
    # find all valid edge cuts
    for (x in nbrs) nbrsNbrMtx = rbind(nbrsNbrMtx, cbind(x, names(which(G[x, ] == 1))))
    
    # remove duplicated edge cuts
    nbrsNbrMtx = remove_duplicated_edges(nbrsNbrMtx)
    
    # backup G
    backup = G
    
    if (debug) cat("remove edges: \n")
    
    for (i in 0:nrow(nbrsNbrMtx)) {
      if (i > 0) {
        # restore backup
        G = backup
        # remove an edge combn
        from = nbrsNbrMtx[i, 1]
        to = nbrsNbrMtx[i, 2]
        G = subgraph(G, from = from, to = to, type = "edges")
        if (debug) cat(from, "-", to, "\n")
      }
      if (is_wrs(G, debug) == 1) {
        return(1)
      } 
    }
    
    
  } 
  
  
  
  return(0)
}



is_chordal2 = function(G) {
  if (length(G) < 10) return(1)
  sim = find_simplicial(G)
  if (length(sim) > 0) {
    #cat("sim:", sim, "\n")
    G = subgraph(G, nodes = sim, type = "nodes")
    if (is_chordal2(G) == 1) return(1)
  } 
  #cat("no sim. \n")
  return(0)
}
```


## Exhaustive search
```{r}

is_wrs = function(G, debug = F) {
  
  if (is_chordal(G)) {
    if (debug) cat("chordal \n")
    return(1)
  }
  
  sim = find_simplicial(G)
  
  
  if (length(sim) > 0) {
    
    nbrsNbrMtx = matrix(0, 0, 2)
    simNbrList = list()
    if (debug) cat("\n *sim:", sim, "\n")
    if (debug) cat("nbrs: \n")
    
    # find sim's nbrs
    for (x in sim) {
      xNbrs = find_nbr(G, x)
      xNbrs = xNbrs[!xNbrs %in% sim]
      simNbrList[[x]] = xNbrs
      if (debug) {
        cat(x, "-", xNbrs, "\n")
      }
    }
    
    # list unique nbrs
    nbrs = unique(unlist(simNbrList))
    
    # omit deleted sim
    nbrs = nbrs[!nbrs %in% sim]
    
    # remove sim 
    G = subgraph(G, nodes = sim, type = "nodes")
    
    # find all valid edge cuts
    for (x in nbrs) {
      y = names(which(G[x, ] == 1))
      if (length(y) > 0) nbrsNbrMtx = rbind(nbrsNbrMtx, cbind(x, y))
    }
    
    # remove duplicated edge cuts
    if (length(nbrsNbrMtx) > 0) nbrsNbrMtx = remove_duplicated_edges(nbrsNbrMtx)
    if (length(nbrsNbrMtx) == 2) nbrsNbrMtx = matrix(nbrsNbrMtx, 1, 2)
    
    # backup G
    backup = G
    
    #nOpts = 2 ^ nrow(nbrsNbrMtx)
    if (debug) cat("remove edges: 2 ^", nrow(nbrsNbrMtx), "options \n")
    
    indices = 0
    i = 0
    while(all.equal(indices, 1:nrow(nbrsNbrMtx)) != TRUE) {
    #for (i in 0:nOpts) {
      if (i > 0) {
        # restore backup
        G = backup
        
        if (nrow(nbrsNbrMtx) > 1) {
          # compute indices   
          indices = combn_ind(i, nrow(nbrsNbrMtx))
        } else {
          indices = i
        }
        
        # iteratively remove edges
        for (ind in indices) {
          from = nbrsNbrMtx[ind, 1]
          to = nbrsNbrMtx[ind, 2]
          G = subgraph(G, from = from, to = to, type = "edges")
        }
        
        if (debug) {
          cat(i, ", ")
        }
        
      } else {
        if (debug) {
          cat(i, ", ")
          #cat("empty set \n")
        }
      }
      if (is_wrs(G, debug) == 1) {
        return(1)
      } 
      i = i + 1
    }# end for i 
    
    
  } 
  return(0)
}
```












