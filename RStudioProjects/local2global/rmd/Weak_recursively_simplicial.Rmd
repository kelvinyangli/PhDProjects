---
title: "Weak recursively simplicial"
author: "Kelvin Li"
date: "21 May 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE, echo = F, eval = T)
if (.Platform$OS.type == "windows") {
  dir = "C:/Users/"
} else {
  dir = "/home/"
}
source(paste0(dir, "kl/Documents/PhDProjects/RStudioProjects/local2global/scripts/load_libraries.R"))
#library(plyr)
library(igraph)
#library(svMisc)
library(wrsgraph)
```

## randomly generating undirected graphs
```{r}
n = 1000
for (i in 1:n) {

  progress(i, 100, n)
  #repeat {
    seed = randSeed()
    set.seed(seed)
    # dag = randDag(30, 3)
    # g = moral(dag)
    # G = dag2matrix(g)
    # vars = colnames(G)
    G = rand_bounded_deg_graph(10, 4)
    #if (!wrsgraph::is_chordal(G)) break
  #}
  
  # g = matrix2dag(G)
  # vars = colnames(G)
  # m.deg = max(sapply(sapply(vars, bnlearn::nbr, x = g), length))
  # checking chordality using wrs and quasi rs (qrs)
  wrs = wrs_bktr(G, G)$wrs # wrs
  dwrs = d_wrs(G) # qrs
  #dwrs = d_wrs(G, G)$wrs
  #if (wrs == 1) break
  # all max.deg<=3 graphs must be both qrs and wrs
  if (wrs != dwrs) break
  
}
i
#seed
#m.deg
```

## plotting
```{r}
G = prune_leaves(G)
#dag = readRDS("~/Documents/wrs_graph_counter_examples/0302018_1345.rds")
# g = moral(dag)
# G = dag2matrix(g)

#par(mfrow=c(1,2))
graphviz.plot(matrix2dag(G))
#graphviz.plot(matrix2dag(G), shape = "rectangle")

write.table(G,"~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx.csv", row.names = F, col.names = F)
nds = as.integer(sapply(colnames(G), gsub, pattern = "[^0-9]", replacement = ""))
write.table(nds, "~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx_nodes.csv", row.names = F, col.names = F)
```

## maximum degree 4 graphs
1. a simplicial clique can certainly be removed to break a cycle
# compare mb
```{r}
res = wrs_bktr(G, D = G, T)
dd = res$dag
dd = matrix2dag(dd)
dagl = cextend(dd)
gEdges = g$arcs
daglEdges = skeleton(dagl)$arcs
removedEdges = matrix(0, 0, 2)
for (i in 1:nrow(gEdges)) {
  if (is.na(row.match(gEdges[i, ], daglEdges))) {
    removedEdges = rbind(removedEdges, gEdges[i, ])
  }
}
removedEdges = remove_duplicated_edges(removedEdges)
if (length(removedEdges) == 2) removedEdges = matrix(removedEdges, 1, 2)
hybridl = dagl
for (i in 1:nrow(removedEdges)) hybridl = set.edge(hybridl, removedEdges[i, 1], removedEdges[i, 2])
par(mfrow=c(1,3))
graphviz.plot(dag)
graphviz.plot(g, shape = "rectangle")
graphviz.plot(dagl, shape = "rectangle")
#graphviz.plot(hybridl, highlight = list("arcs" = removedEdges), shape = "rectangle")
acyclic(dagl)
vars = bnlearn::nodes(dag)
all.equal(sapply(vars, mb, x = dagl), sapply(vars, mb, x = dag))
bnlearn::hamming(dagl, dag) # skeleton dif
bnlearn::shd(dagl, dag) # pattern dif
mean(sapply(vars, bnlearn::degree, object = dagl))
mean(sapply(vars, bnlearn::degree, object = dag))
```

## functions
1. a function to find nbrs
2. a function to identify clique among vars
3. a function to test simplicity of a node
4. a function to find all simplicial nodes 
```{r}
# a function to compute the total degree of a node in an undirected graph


# identify if a given set of nodes are simplicial in a graph
# names(nbrsList) must contain the given nodes
are_simplicial = function(graph, nodes) {
  
  sim = rep(0, length(nodes))
  i = 1
  for (x in nodes) {
    sim[i] = is_simplicial(graph, x)
    i = i + 1
  }
  return(sim)
  
}

# check if a graph is empty
is_empty_graph = function(graph) {
  
  empty = 0
  if (sum(graph) < 1) empty = 1
  return(empty)
  
}

# a function to find common nbrs of two nodes 
common_nbrs = function(graph, x, y) {
  
  xNbrs = names(which(graph[x, ] == 1))
  yNbrs = names(which(graph[y, ] == 1))
  return(intersect(xNbrs, yNbrs))
  
}

# a function to list all edges
edge_set = function(graph, nodes) {
  
  m = matrix(0, ncol = 2, nrow = sum(graph[nodes, nodes]) / 2)
  k = 1
  for (i in 1:(length(nodes) - 1)) {
    for (j in (i + 1):length(nodes)) {
      m[k, ] = c(nodes[c(i, j)])
      k = k + 1
    }
  }
  return(m)
  
}

# a function to find the minimal edges cut to make a non-sim node x into a sim node in subG
# subset is a vector of nodes that must be appeared in all cliques, it could be empty
minimal_edges_cut = function(subG, x, xNbrs, subset) {
  
  # the task here is to find the maximal clique from c(removed, remained) 
  # that contains all nodes in remained
  ig = igraph::graph_from_adjacency_matrix(subG[xNbrs, xNbrs], mode = "undirected")
  # run cliques(ig, min = 3) to find all cliques w/ >= 3 nodes 
  # and idenfity the maximal clique containing remained 
  # if no such a clique then the minimal edge cut to make node sim 
  # is the set of edges b/w nodea nd removed 
  allQ = cliques(ig, min = length(subset))
  qSizes = sapply(allQ, length)
  keep = rep(1, length(allQ))
  if (length(subset) > 0) {
    for (i in 1:length(allQ)) {
      if (prod(subset %in% names(allQ[[i]])) == 0) keep[i] = 0
    }
  }
  
  maxQSize = qSizes[max(which(keep == 1))]
  maxQList = allQ[keep == 1][which(qSizes[keep == 1] == maxQSize)]
  edgesCut = rep(list(NULL), length(maxQList))
  for (i in 1:length(maxQList)) {
    edgesCut[[i]] = c(edgesCut[[i]], xNbrs[!xNbrs %in% names(maxQList[[i]])])
  }
  return(edgesCut)
  
}

# find all possible edge cut that makes x a sim node in the remaining graph
# the output is a list of edge cut, ordered from min to max # of edges
all_edges_cut = function(subG, x, xNbrs, subset) {
  
  ig = igraph::graph_from_adjacency_matrix(subG[xNbrs, xNbrs], mode = "undirected")
  allQ = cliques(ig, min = length(subset))
  keep = rep(1, length(allQ))
  if (length(subset) > 0) {
    for (i in 1:length(allQ)) {
      if (prod(subset %in% names(allQ[[i]])) == 0) keep[i] = 0
    }
  }
  allQ = allQ[keep == 1]
  lst = list()
  for (i in 1:length(allQ)) {
      lst[[i]] = xNbrs[!xNbrs %in% names(allQ[[i]])]
  }
  lst = rev(lst)
  return(lst)
  
}

# a function to find each sim's nbrs' nbr restricted to the simNbrList
find_nbrsNbrList = function(simNbrList, nbrs, debug = F) {
  nbrsNbrList = rep(list(NULL), length(nbrs))
  i = 1
  for (x in nbrs) {
    ind = sapply(simNbrList, is.element, el = x)
    xNbrs = unique(unlist(simNbrList[ind]))
    xNbrs = xNbrs[xNbrs != x] # remove x itself
    nbrsNbrList[[i]] = xNbrs
    i = i + 1
    if (debug) cat(x, "-", xNbrs, "\n")
  }
  names(nbrsNbrList) = nbrs
  return(nbrsNbrList)
}
```

## d-wrs
```{r}
d_wrs = function(G, D, debug = F) {

  # return T if G is chordal
  if (wrsgraph::is_chordal(G)) {

    if (debug) cat("chordal \n")
    return(list(wrs = 1, dag = D))

  }

  # prune all leave in G
  # since chordality is check before prunning leaves
  # the graph after pruning is guaranteed to be non-empty
  G = prune_leaves(G)
  
  # find all sim nodes in G
  sim = find_simplicial(G)

  # proceed if G has sim nodes
  if (length(sim) > 0) {
    #sim = sim[1] # remove one sim at a time
    # a matrix to store all valid edges that can be removed
    nbrsNbrMtx = matrix(0, 0, 2)
    simNbrList = list()
    if (debug) cat("sim:", sim, "\n")
    #if (debug) cat("nbrs: \n")

    # for each sim node x...
    for (x in sim) {

      # ... find its nbrs in G
      xNbrs = find_nbr(G, x)
      # ... omit deleted sim
      xNbrs = xNbrs[!xNbrs %in% sim]
      # ... store them in a list
      simNbrList[[x]] = xNbrs
      # if (debug) {
      #   cat(x, "-", xNbrs, "\n")
      # }
      # ... orient D
      D[x, xNbrs] = 0

    }

    # list unique nbrs
    nbrs = unique(unlist(simNbrList))

    # remove sim
    G = wrsgraph::subgraph(G, nodes = sim, type = "nodes")
    for (x in nbrs) {

      for (i in 1:length(simNbrList)) {
        if (is.element(x, simNbrList[[i]])) {
          if (length(simNbrList[[i]]) > 1) {

            xNbrs = simNbrList[[i]]
            xNbrs = xNbrs[xNbrs != x]
            xNbrs = xNbrs[!xNbrs %in% sim]
            nbrsNbrMtx = rbind(nbrsNbrMtx, cbind(x, xNbrs))

          }
        }
      }
    }

    # remove duplicated edge cuts
    if (length(nbrsNbrMtx) > 0) nbrsNbrMtx = remove_duplicated_edges(nbrsNbrMtx)
    if (length(nbrsNbrMtx) == 2) nbrsNbrMtx = matrix(nbrsNbrMtx, 1, 2)

    if ((debug) && (nrow(nbrsNbrMtx) > 0)) cat("#edges:", nrow(nbrsNbrMtx), "\n")

    if (nrow(nbrsNbrMtx) > 0) {

      # backup G
      backupG = G
      # backup D
      backupD = D

      #indices = c()
      #i = 1
      i = 2 ^ nrow(nbrsNbrMtx) # start from removing all edges to remove nothing
      # remove each edge combination and apply wrs_bktr()
      #while (i < (i_max + 1)) {
      #while (i > 0) {
        if (debug) cat(sim, "-", i, "\n")
        # when i=1, remove nothing
        # restore backup
        G = backupG
        D = backupD
          
        # when i > 1, remove edges
        if (i > 1) {

          # restore backup
          # G = backupG
          # D = backupD

          # compute indices
          indices = combn_ind(i, nrow(nbrsNbrMtx))
          #if (debug) cat(indices, "\n")
          #cat(indices, "\n")
          # if (nrow(nbrsNbrMtx) > 1) {
          #   # compute indices
          #   indices = combn_ind(i, nrow(nbrsNbrMtx))
          # } else {# when there is only one option
          #   indices = i
          # }

          # iteratively remove edges
          for (ind in indices) {
            from = nbrsNbrMtx[ind, 1]
            to = nbrsNbrMtx[ind, 2]
            G = wrsgraph::subgraph(G, from = from, to = to, type = "edges")
            D = wrsgraph::subgraph(D, from = from, to = to, type = "edges")
          }

        }

        # apply wrs_bktr recursively
        res = d_wrs(G, D, debug)
        if (res$wrs == 1) {

          D = res$dag
          return(list(wrs = 1, dag = D))

        }

        #i = i - 1 # decremental i because we start from full set of edges

      #}# end while
    } else {

      # apply wrs_bktr recursively
      res = d_wrs(G, D, debug)
      if (res$wrs == 1) {

        D = res$dag
        return(list(wrs = 1, dag = D))

      }
    }
  }

  return(list(wrs = 0))

}
```


# wrs_bktr_alt
```{r}
wrs_bktr_alt = function(G, D, debug = F) {

  # return T if G is chordal
  if (is_chordal(G)) {

    if (debug) cat("chordal \n")
    return(list(wrs = 1, dag = D))

  }
  
  # prune all leave in G
  # since chordality is check before prunning leaves
  # the resulting graph is non-empty
  G = prune_leaves(G)

  # find all sim nodes in G
  sim = find_simplicial(G)

  # all remaining simplicial nodes should have at least 2 neighbours
  # proceed if G has sim nodes, else return F
  if (length(sim) > 0) {
    sim = sim[1]
    # if it's a simplicial K4, remove the K4
    simNbrs = wrsgraph::find_nbr(G, sim)
    if (length(simNbrs) == 3 ) {
      G = wrsgraph::subgraph(G, nodes = c(sim, simNbrs), type = "clique")
    } else {
      # if it's a simplicial K3, remove edge accordingly
      # remove sim node first
      G = wrsgraph::subgraph(G, nodes = sim, type = "nodes") 
      newSims = find_simplicial(G)
      if (sum(simNbrs %in% newSims) < 1) {
        # if simNbrs are not sim then 
      }
    }
    
    # a matrix to store all valid edges that can be removed
    nbrsNbrMtx = matrix(0, 0, 2)
    simNbrList = list()
    if (debug) cat("sim:", sim, "\n")
    #if (debug) cat("nbrs: \n")

    # for each sim node x...
    for (x in sim) {

      # ... find its nbrs in G
      xNbrs = find_nbr(G, x)
      # ... omit deleted sim
      xNbrs = xNbrs[!xNbrs %in% sim]
      # ... store them in a list
      simNbrList[[x]] = xNbrs
      # if (debug) {
      #   cat(x, "-", xNbrs, "\n")
      # }
      # ... orient D
      D[x, xNbrs] = 0

    }

    # list unique nbrs
    nbrs = unique(unlist(simNbrList))

    # # omit deleted sim
    # nbrs = nbrs[!nbrs %in% sim]

    # remove sim
    G = subgraph(G, nodes = sim, type = "nodes")
    for (x in nbrs) {

      for (i in 1:length(simNbrList)) {
        if (is.element(x, simNbrList[[i]])) {
          if (length(simNbrList[[i]]) > 1) {

            xNbrs = simNbrList[[i]]
            xNbrs = xNbrs[xNbrs != x]
            xNbrs = xNbrs[!xNbrs %in% sim]
            nbrsNbrMtx = rbind(nbrsNbrMtx, cbind(x, xNbrs))

          }
        }
      }
    }

    # remove duplicated edge cuts
    if (length(nbrsNbrMtx) > 0) nbrsNbrMtx = remove_duplicated_edges(nbrsNbrMtx)
    if (length(nbrsNbrMtx) == 2) nbrsNbrMtx = matrix(nbrsNbrMtx, 1, 2)
    if ((debug) && (nrow(nbrsNbrMtx) > 0)) cat("#edges:", nrow(nbrsNbrMtx), "\n")
    if (nrow(nbrsNbrMtx) > 0) {

      # backup G
      backupG = G
      # backup D
      backupD = D

      indices = c()
      i = 1
      # remove each edge combination and apply wrs_bktr()
      while (length(indices) < nrow(nbrsNbrMtx)) {
        if (debug) cat(sim, "-", i, "\n")
        #if (debug) cat(".")
        # when i=1, remove nothing
        # when i > 1, remove edges
        if (i > 1) {

          # restore backup
          G = backupG
          D = backupD

          # compute indices
          indices = combn_ind(i, nrow(nbrsNbrMtx))

          # if (nrow(nbrsNbrMtx) > 1) {
          #   # compute indices
          #   indices = combn_ind(i, nrow(nbrsNbrMtx))
          # } else {# when there is only one option
          #   indices = i
          # }

          # iteratively remove edges
          for (ind in indices) {
            from = nbrsNbrMtx[ind, 1]
            to = nbrsNbrMtx[ind, 2]
            G = subgraph(G, from = from, to = to, type = "edges")
            D = subgraph(D, from = from, to = to, type = "edges")
          }

        }

        # apply wrs_bktr recursively
        res = wrs_bktr_alt(G, D, debug)
        if (res$wrs == 1) {

          D = res$dag
          return(list(wrs = 1, dag = D))

        }

        i = i + 1

      }# end while
    } else {

      # apply wrs_bktr recursively
      res = wrs_bktr_alt(G, D, debug)
      if (res$wrs == 1) {

        D = res$dag
        return(list(wrs = 1, dag = D))

      }
    }
  }

  return(list(wrs = 0))

}
```








