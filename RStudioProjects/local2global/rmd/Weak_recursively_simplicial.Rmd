---
title: "Weak recursively simplicial"
author: "Kelvin Li"
date: "21 May 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE, echo = F, eval = T)
if (.Platform$OS.type == "windows") {
  dir = "C:/Users/"
} else {
  dir = "/home/"
}
source(paste0(dir, "kl/Documents/PhDProjects/RStudioProjects/local2global/scripts/load_libraries.R"))
#library(plyr)
library(igraph)
#library(svMisc)
library(wrsgraph)
```

## randomly generating undirected graphs
```{r}
n = 1000000
no_cores = 3
registerDoParallel(no_cores)
res = foreach(i = 1:n, .combine="c") %dopar% {
  G = rand_bounded_deg_graph(15, 4)
  wrs = wrs_bktr(G, G)$wrs # wrs
  dwrs = d_wrs_deg4(G) # qrs
  wrs == dwrs
  #if (wrs != dwrs) break
}
stopImplicitCluster()
#for (i in 1:n) {

  #progress(i, 1000, n)
  #repeat {
    # seed = randSeed()
    # set.seed(seed)
    # dag = randDag(30, 3)
    # g = moral(dag)
    # G = dag2matrix(g)
    # vars = colnames(G)
    
    #saveRDS(G, "~/Documents/PhDProjects/RStudioProjects/wrsgraph/test.rds")
    #cat(seed, "-")
    #if (!wrsgraph::is_chordal(G)) break
  #}
  
  # g = matrix2dag(G)
  # vars = colnames(G)
  # m.deg = max(sapply(sapply(vars, bnlearn::nbr, x = g), length))
  # checking chordality using wrs and quasi rs (qrs)
  
  #dwrs = d_wrs(G, G)$wrs
  #if (wrs == 1) break
  # all max.deg<=3 graphs must be both qrs and wrs
  
  
  
#}


```

```{r}
#seed
#m.deg

## plotting
g = G
G = prune_leaves(G)
#dag = readRDS("~/Documents/wrs_graph_counter_examples/0302018_1345.rds")
# g = moral(dag)
# G = dag2matrix(g)

#par(mfrow=c(1,2))
graphviz.plot(matrix2dag(G))
#graphviz.plot(matrix2dag(G), shape = "rectangle")

write.table(G,"~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx.csv", row.names = F, col.names = F)
nds = as.integer(sapply(colnames(G), gsub, pattern = "[^0-9]", replacement = ""))
write.table(nds, "~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx_nodes.csv", row.names = F, col.names = F)
```


# compare mb
```{r}
res = wrs_bktr(G, D = G, T)
dd = res$dag
dd = matrix2dag(dd)
dagl = cextend(dd)
gEdges = g$arcs
daglEdges = skeleton(dagl)$arcs
removedEdges = matrix(0, 0, 2)
for (i in 1:nrow(gEdges)) {
  if (is.na(row.match(gEdges[i, ], daglEdges))) {
    removedEdges = rbind(removedEdges, gEdges[i, ])
  }
}
removedEdges = remove_duplicated_edges(removedEdges)
if (length(removedEdges) == 2) removedEdges = matrix(removedEdges, 1, 2)
hybridl = dagl
for (i in 1:nrow(removedEdges)) hybridl = set.edge(hybridl, removedEdges[i, 1], removedEdges[i, 2])
par(mfrow=c(1,3))
graphviz.plot(dag)
graphviz.plot(g, shape = "rectangle")
graphviz.plot(dagl, shape = "rectangle")
#graphviz.plot(hybridl, highlight = list("arcs" = removedEdges), shape = "rectangle")
acyclic(dagl)
vars = bnlearn::nodes(dag)
all.equal(sapply(vars, mb, x = dagl), sapply(vars, mb, x = dag))
bnlearn::hamming(dagl, dag) # skeleton dif
bnlearn::shd(dagl, dag) # pattern dif
mean(sapply(vars, bnlearn::degree, object = dagl))
mean(sapply(vars, bnlearn::degree, object = dag))
```

## functions
1. a function to find nbrs
2. a function to identify clique among vars
3. a function to test simplicity of a node
4. a function to find all simplicial nodes 
```{r}
# a function to compute the total degree of a node in an undirected graph


# identify if a given set of nodes are simplicial in a graph
# names(nbrsList) must contain the given nodes
are_simplicial = function(graph, nodes) {
  
  sim = rep(0, length(nodes))
  i = 1
  for (x in nodes) {
    sim[i] = is_simplicial(graph, x)
    i = i + 1
  }
  return(sim)
  
}

# check if a graph is empty
is_empty_graph = function(graph) {
  
  empty = 0
  if (sum(graph) < 1) empty = 1
  return(empty)
  
}



# a function to list all edges
edge_set = function(graph, nodes) {
  
  m = matrix(0, ncol = 2, nrow = sum(graph[nodes, nodes]) / 2)
  k = 1
  for (i in 1:(length(nodes) - 1)) {
    for (j in (i + 1):length(nodes)) {
      m[k, ] = c(nodes[c(i, j)])
      k = k + 1
    }
  }
  return(m)
  
}

# a function to find the minimal edges cut to make a non-sim node x into a sim node in subG
# subset is a vector of nodes that must be appeared in all cliques, it could be empty
minimal_edges_cut = function(subG, x, xNbrs, subset) {
  
  # the task here is to find the maximal clique from c(removed, remained) 
  # that contains all nodes in remained
  ig = igraph::graph_from_adjacency_matrix(subG[xNbrs, xNbrs], mode = "undirected")
  # run cliques(ig, min = 3) to find all cliques w/ >= 3 nodes 
  # and idenfity the maximal clique containing remained 
  # if no such a clique then the minimal edge cut to make node sim 
  # is the set of edges b/w nodea nd removed 
  allQ = cliques(ig, min = length(subset))
  qSizes = sapply(allQ, length)
  keep = rep(1, length(allQ))
  if (length(subset) > 0) {
    for (i in 1:length(allQ)) {
      if (prod(subset %in% names(allQ[[i]])) == 0) keep[i] = 0
    }
  }
  
  maxQSize = qSizes[max(which(keep == 1))]
  maxQList = allQ[keep == 1][which(qSizes[keep == 1] == maxQSize)]
  edgesCut = rep(list(NULL), length(maxQList))
  for (i in 1:length(maxQList)) {
    edgesCut[[i]] = c(edgesCut[[i]], xNbrs[!xNbrs %in% names(maxQList[[i]])])
  }
  return(edgesCut)
  
}

# find all possible edge cut that makes x a sim node in the remaining graph
# the output is a list of edge cut, ordered from min to max # of edges
all_edges_cut = function(subG, x, xNbrs, subset) {
  
  ig = igraph::graph_from_adjacency_matrix(subG[xNbrs, xNbrs], mode = "undirected")
  allQ = cliques(ig, min = length(subset))
  keep = rep(1, length(allQ))
  if (length(subset) > 0) {
    for (i in 1:length(allQ)) {
      if (prod(subset %in% names(allQ[[i]])) == 0) keep[i] = 0
    }
  }
  allQ = allQ[keep == 1]
  lst = list()
  for (i in 1:length(allQ)) {
      lst[[i]] = xNbrs[!xNbrs %in% names(allQ[[i]])]
  }
  lst = rev(lst)
  return(lst)
  
}

# a function to find each sim's nbrs' nbr restricted to the simNbrList
find_nbrsNbrList = function(simNbrList, nbrs, debug = F) {
  nbrsNbrList = rep(list(NULL), length(nbrs))
  i = 1
  for (x in nbrs) {
    ind = sapply(simNbrList, is.element, el = x)
    xNbrs = unique(unlist(simNbrList[ind]))
    xNbrs = xNbrs[xNbrs != x] # remove x itself
    nbrsNbrList[[i]] = xNbrs
    i = i + 1
    if (debug) cat(x, "-", xNbrs, "\n")
  }
  names(nbrsNbrList) = nbrs
  return(nbrsNbrList)
}
```

## d-wrs
```{r}
d_wrs = function(G, D, debug = F) {

  # return T if G is chordal
  if (wrsgraph::is_chordal(G)) {

    if (debug) cat("chordal \n")
    return(list(wrs = 1, dag = D))

  }

  # prune all leave in G
  # since chordality is check before prunning leaves
  # the graph after pruning is guaranteed to be non-empty
  G = prune_leaves(G)
  
  # find all sim nodes in G
  sim = find_simplicial(G)

  # proceed if G has sim nodes
  if (length(sim) > 0) {
    #sim = sim[1] # remove one sim at a time
    # a matrix to store all valid edges that can be removed
    nbrsNbrMtx = matrix(0, 0, 2)
    simNbrList = list()
    if (debug) cat("sim:", sim, "\n")
    #if (debug) cat("nbrs: \n")

    # for each sim node x...
    for (x in sim) {

      # ... find its nbrs in G
      xNbrs = find_nbr(G, x)
      # ... omit deleted sim
      xNbrs = xNbrs[!xNbrs %in% sim]
      # ... store them in a list
      simNbrList[[x]] = xNbrs
      # if (debug) {
      #   cat(x, "-", xNbrs, "\n")
      # }
      # ... orient D
      D[x, xNbrs] = 0

    }

    # list unique nbrs
    nbrs = unique(unlist(simNbrList))

    # remove sim
    G = wrsgraph::subgraph(G, nodes = sim, type = "nodes")
    for (x in nbrs) {

      for (i in 1:length(simNbrList)) {
        if (is.element(x, simNbrList[[i]])) {
          if (length(simNbrList[[i]]) > 1) {

            xNbrs = simNbrList[[i]]
            xNbrs = xNbrs[xNbrs != x]
            xNbrs = xNbrs[!xNbrs %in% sim]
            nbrsNbrMtx = rbind(nbrsNbrMtx, cbind(x, xNbrs))

          }
        }
      }
    }

    # remove duplicated edge cuts
    if (length(nbrsNbrMtx) > 0) nbrsNbrMtx = remove_duplicated_edges(nbrsNbrMtx)
    if (length(nbrsNbrMtx) == 2) nbrsNbrMtx = matrix(nbrsNbrMtx, 1, 2)

    if ((debug) && (nrow(nbrsNbrMtx) > 0)) cat("#edges:", nrow(nbrsNbrMtx), "\n")

    if (nrow(nbrsNbrMtx) > 0) {

      # backup G
      backupG = G
      # backup D
      backupD = D

      #indices = c()
      #i = 1
      i = 2 ^ nrow(nbrsNbrMtx) # start from removing all edges to remove nothing
      # remove each edge combination and apply wrs_bktr()
      #while (i < (i_max + 1)) {
      #while (i > 0) {
        if (debug) cat(sim, "-", i, "\n")
        # when i=1, remove nothing
        # restore backup
        G = backupG
        D = backupD
          
        # when i > 1, remove edges
        if (i > 1) {

          # restore backup
          # G = backupG
          # D = backupD

          # compute indices
          indices = combn_ind(i, nrow(nbrsNbrMtx))
          #if (debug) cat(indices, "\n")
          #cat(indices, "\n")
          # if (nrow(nbrsNbrMtx) > 1) {
          #   # compute indices
          #   indices = combn_ind(i, nrow(nbrsNbrMtx))
          # } else {# when there is only one option
          #   indices = i
          # }

          # iteratively remove edges
          for (ind in indices) {
            from = nbrsNbrMtx[ind, 1]
            to = nbrsNbrMtx[ind, 2]
            G = wrsgraph::subgraph(G, from = from, to = to, type = "edges")
            D = wrsgraph::subgraph(D, from = from, to = to, type = "edges")
          }

        }

        # apply wrs_bktr recursively
        res = d_wrs(G, D, debug)
        if (res$wrs == 1) {

          D = res$dag
          return(list(wrs = 1, dag = D))

        }

        #i = i - 1 # decremental i because we start from full set of edges

      #}# end while
    } else {

      # apply wrs_bktr recursively
      res = d_wrs(G, D, debug)
      if (res$wrs == 1) {

        D = res$dag
        return(list(wrs = 1, dag = D))

      }
    }
  }

  return(list(wrs = 0))

}
```


## max.deg = 4
```{r}
d_wrs_deg4 = function(G, debug = F) {
  
  # return T if G is chordal
  if (wrsgraph::is_chordal(G)) {
    
    if (debug) cat("chordal \n")
    return(wrs = 1)
    
  }
  
  # prune all leave in G
  # since chordality is check before prunning leaves
  # the graph after pruning is guaranteed to be non-empty
  if (debug) cat("prune leaves \n")
  G = prune_leaves(G)
  
  # find all sim nodes in G
  # after prune, all simplicial nodes have at least 2 nbrs
  if (debug) cat("find sims \n")
  sim = find_simplicial(G)
  
  simNbrList = list()
  nK3s = c()
  # 0. caculate length of k3 stacks and nbrs of sim nodes
  if (length(sim) > 0) {
    # count nbrs for each sim node
    simNbrList = lapply(sim, wrsgraph::find_nbr, graph = G)
    names(simNbrList) = sim
    # calculate the length of a stack of k3s, ranges from 1 to many
    nK3s = rep(0, length(sim))
    for (i in 1:length(sim)) {
      nK3s[i] = k3_ladder(G, sim[i], simNbrList[[i]][1], simNbrList[[i]][2], 1)  
    }
  }
  
  # 1. k4+... or k5
  ind = which(sapply(simNbrList, length) > 2)
  if (length(ind) > 0) {
    if (debug) cat("step 1 \n")
    i = ind[1]
    G = wrsgraph::subgraph(G, nodes = c(sim[i], simNbrList[[i]]), type = "clique")  
    res = d_wrs_deg4(G)
    if (res == 1) {
      return(wrs = 1)
    } else {
      return(wrs = 0)  
    }
  }
  
  # 2. k3+{k3,k4,2*k3}
  ind = which(nK3s %in% c(-1, 2))
  if (length(ind) > 0) {
    if (debug) cat("step 2 \n")
    i = ind[1]
    G = wrsgraph::subgraph(G, nodes = sim[i], type = "nodes")
    res = d_wrs_deg4(G)
    if (res == 1) {
      return(wrs = 1)
    } else {
      return(wrs = 0)  
    }
  }
  
  # 3. k3+{stack of 3 k3s, cm, share no edge}
  ind = which(nK3s %in% c(0, 1))
  if (length(ind) > 0) {
    if (debug) cat("step 3 \n")
    i = ind[1]
    G = wrsgraph::subgraph(G, nodes = c(sim[i], simNbrList[[i]]), type = "clique")    
    res = d_wrs_deg4(G)
    if (res == 1) {
      return(wrs = 1)
    } else {
      return(wrs = 0)  
    }
  }
  
  # all the sim nodes left are in length >= 3 stack of k3s
  # 
  # 4.0 deal with cases when a stack has length > 3
  # in this case, remove a simplicial k3
  ind = which(nK3s > 3) 
  if (length(ind) > 0) {
    if (debug) cat("step 4.0 \n")
    i = ind[1]
    G = wrsgraph::subgraph(G, nodes = c(sim[i], simNbrList[[i]]), type = "clique")    
    res = d_wrs_deg4(G)
    if (res == 1) {
      return(wrs = 1)
    } else {
      return(wrs = 0)  
    }
  }
  
  # 4.1 order k3 stacks so that sp is dealt at last
  ind = which(nK3s == 3)
  if (length(ind) > 0) {
    if (debug) cat("step 4.1 \n")
    ind = c()
    for (i in 1:length(sim)) {
      mtch = matching_special_envelop_graph(G, sim[i])
      if (mtch == 1) ind = c(ind, i)
    }
    
    # in the current graph, if there are two sim nodes in the same stack
    # the only possibility is that they are both in the special sp graph
    # if this is the case, they will be recorded in ind by the subgraph 
    # matching process, hence the rest sim nodes are safely to be removed
    # together, since they aren't in the same stack
    # disconnected graph? a stack of 3 k3s?
    if (length(ind) < length(sim)) {
      if (length(ind) > 0) {
        sim = sim[-ind]
        simNbrList = simNbrList[-ind]
        nK3s = nK3s[-ind]
      }
      i = 1
      G = wrsgraph::subgraph(G, nodes = c(sim[i], simNbrList[[i]]), type = "clique") 
      res = d_wrs_deg4(G)
      if (res == 1) {
        return(wrs = 1)
      } else {
        return(wrs = 0)  
      }
    } else {
      # when all sim nodes are in special sp graph
      if (length(sim) > 1) {
        # check for two nodes in the same stack case
        ind = c()
        for (i in 1:(length(sim) - 1)) {
          for (j in (i + 1):length(sim)) {
            # since max.deg=4, there is max 1 common nbr in the rest of the graph
            # so remove both sim nodes
            if (length(intersect(simNbrList[[i]], simNbrList[[j]])) == 1) {
              ind = c(ind, i, j)
            }
          }
        }
        # 4.1 if two are in the same stack, remove both sim nodes
        if (length(ind) > 0) {
          G = wrsgraph::subgraph(G, nodes = sim[ind], type = "nodes")
          res = d_wrs_deg4(G)
          if (res == 1) {
            return(wrs = 1)
          } else {
            return(wrs = 0)  
          }
        } else {
          # remove a random sim k3
          i = 1
          G = wrsgraph::subgraph(G, nodes = c(sim[i], simNbrList[[i]]), type = "clique") 
          res = d_wrs_deg4(G)
          if (res == 1) {
            return(wrs = 1)
          } else {
            return(wrs = 0)  
          }
        }
      } else {# when there is only 1 sim node left in a stack of 3 k3s
        # remove the sim k3
        i = 1
        G = wrsgraph::subgraph(G, nodes = c(sim[i], simNbrList[[i]]), type = "clique") 
        res = d_wrs_deg4(G)
        if (res == 1) {
          return(wrs = 1)
        } else {
          return(wrs = 0)  
        }
      }
    }
  }
  
  return(wrs = 0)
  
}


```


# matching subgraph sp
```{r}
# matching for "special envelop" subgraph
# the function will return NA if the node is not a sim node in a stack 
# of 3 k3s
matching_special_envelop_graph = function(G, node) {
  
  cycle = 0
  nbrs = find_nbr(G, node)
  x = nbrs[1]
  y = nbrs[2]
  z = common_nbrs(G, x, y)
  z = z[z != node]
  if (length(common_nbrs(G, z, y)) < 2) {
    # y and z form the middle edge e in the stack of 3
    e1 = y
    w = common_nbrs(G, x, z)
    w = w[w != y]
    exclNodes = c(node, x, w)
  } else {
    e1 = x
    w = common_nbrs(G, y, z)
    w = w[w != x]
    exclNodes = c(node, y, w)
  }
  e2 = z
  # check whether e1 and e2 form a cycle when removing exclNodes
  tempG = wrsgraph::subgraph(G, nodes = exclNodes, type = "nodes")
  if (calculate_cycle_length(tempG, e1, e2, connected = T) > 0) {
    cycle = 1
  }
  
  return(cycle)
  
}
```







