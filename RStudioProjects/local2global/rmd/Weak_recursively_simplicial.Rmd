---
title: "Weak recursively simplicial"
author: "Kelvin Li"
date: "21 May 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE, echo = F, eval = T)
if (.Platform$OS.type == "windows") {
  dir = "C:/Users/"
} else {
  dir = "/home/"
}
source(paste0(dir, "kl/Documents/PhDProjects/RStudioProjects/local2global/scripts/load_libraries.R"))
library(plyr)
library(igraph)
library(svMisc)
```

## randomly generating undirected graphs
```{r}
n = 1000
for (i in 1:n) {
  cat(i, "\n")
# randomly generate a w.r.s. graph
  repeat {
    sd = randSeed()
    set.seed(sd)
    dag = randDag(15, 5)
    g = moral(dag)
    G = dag2matrix(g)
    if (!is_chordal(G)) break
  }
  vars = colnames(G)
  if (!is_wrs7(G)) {
    break
  }
}

i
```

## plotting
```{r}
#dag = randDag(10, 4)
#dag = readRDS("~/Documents/PhDProjects/RStudioProjects/lglbnlearn/counter_example.rds")
g = moral(dag)
G = dag2matrix(g)
vars = colnames(G)
is_wrs5(G)
is_wrs6(G)
is_wrs7(G)
graph = G
nodes = colnames(graph)
nbrsList = lapply(nodes, find_nbr, graph = graph)
names(nbrsList) = nodes
(simplicialNodes = find_simplicial(graph))
par(mfrow=c(1,2))
graphviz.plot(dag)
graphviz.plot(g)
#identify cycles in F, protect the clique that can break the cycles. 
write.csv(G, "~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx.csv", row.names = F)
```

# compare mb
```{r}
dd = read.csv("~/Documents/PhDProjects/RStudioProjects/lglbnlearn/adj_mtx.csv", header = T)
row.names(dd) = colnames(dd)
dd = matrix2dag(dd)
acyclic(dd)
all.equal(sapply(nodes, mb, x = dd), sapply(nodes, mb, x = dag))
```

## functions
1. a function to find nbrs
2. a function to identify clique among vars
3. a function to test simplicity of a node
4. a function to find all simplicial nodes 
```{r}
# a function to remove duplicated rows in a data frame
remove_df_duplicated_with_no_order = function(df) {
  
  for (i in 1:nrow(df)) df[i, ] = df[i, ][order(df[i, ])]
  df = df[!duplicated.data.frame(df), ]
  row.names(df) = c()
  return(df)
  
}

# graph is an adj mtx with col and row names equal to vars
# the outputs are var names 
find_nbr = function(graph, node) names(which(graph[node, ] == 1))

# a function to compute the total degree of a node in an undirected graph
degree = function(graph, node) {
  
  nbrs = find_nbr(graph, node)
  return(length(nbrs))
  
}

# identify if the given nodes form a clique
is_clique = function(graph, nodes) {
  
  clq = 1
  for (i in 1:(length(nodes) - 1)) {
    
    if (clq == 0) break
    x = nodes[i]
    for (j in (i + 1):length(nodes)) {
      
      y = nodes[j]
      if (graph[x, y] != 1) {
        clq = 0
        break
      }
      
    }
    
  }
  return(clq)
}

# identify if a given node is simplicial in a graph
is_simplicial = function(graph, node) {
  
  nbrs = names(which(graph[node, ] == 1))
  if (length(nbrs) < 2) {
    clq = 1
  } else {
    clq = is_clique(graph, nbrs)
  }
  return(clq)
  
}

# identify if a given set of nodes are simplicial in a graph
# names(nbrsList) must contain the given nodes
are_simplicial = function(graph, nodes) {
  
  sim = rep(0, length(nodes))
  i = 1
  for (x in nodes) {
    sim[i] = is_simplicial(graph, x)
    i = i + 1
  }
  return(sim)
  
}

# find all simplicial nodes in a graph
# treat isolated node as a simplicial node for programming convenience
# the output is a vector of simplicial nodes in a graph, ordered by degree ascending
find_simplicial = function(graph) {
  
  nodes = colnames(graph)
  sim = c()
  degrees = c()
  for (x in nodes) {
    nbrs = names(which(graph[x, ] == 1))
    if (length(nbrs) < 1) {
      sim = c(sim, x)
      degrees = c(degrees, 0)
    } else {
      if (is_simplicial(graph, x)) {
        sim = c(sim, x)
        degrees = c(degrees, length(nbrs))
      }
    }
  }
  if (length(sim) > 1) sim = sim[order(degrees)]
  return(sim)
  
}

# get subgraph by removing a node x
subgraph = function(graph, nodes, type = c("nodes", "edges")) {
  
  if (type == "nodes") {
    nodeIndex = which(colnames(graph) %in% nodes)  
    graph = graph[-nodeIndex, -nodeIndex]
  } else if (type == "edges") {
    for (x in nodes) {
      for (y in nodes[nodes != x]) {
        graph[x, y] = 0
      }
    }
  }
  return(graph)
  
}

# check if a graph is empty
is_empty_graph = function(graph) {
  
  empty = 0
  if (sum(graph) < 1) empty = 1
  return(empty)
  
}

# check if a graph (in adj mtx format) is chordal using igraph::is_chordal
is_chordal = function(graph) {
  
  ig = igraph::graph_from_adjacency_matrix(graph, mode = "undirected")
  return(as.numeric(igraph::is_chordal(ig)$chordal))
  
}

# a function to find common nbrs of two nodes 
common_nbrs = function(graph, x, y) {
  
  xNbrs = names(which(graph[x, ] == 1))
  yNbrs = names(which(graph[y, ] == 1))
  return(intersect(xNbrs, yNbrs))
  
}


# a function to list all edges
edge_set = function(graph, nodes) {
  
  m = matrix(0, ncol = 2, nrow = sum(graph[nodes, nodes]) / 2)
  k = 1
  for (i in 1:(length(nodes) - 1)) {
    for (j in (i + 1):length(nodes)) {
      m[k, ] = c(nodes[c(i, j)])
      k = k + 1
    }
  }
  return(m)
  
}

# a function to find the minimal edges cut to make a non-sim node x into a sim node in subG
# subset is a vector of nodes that must be appeared in all cliques, it could be empty
minimal_edges_cut = function(subG, x, xNbrs, subset) {
  
  # the task here is to find the maximal clique from c(removed, remained) 
  # that contains all nodes in remained
  ig = igraph::graph_from_adjacency_matrix(subG[xNbrs, xNbrs], mode = "undirected")
  # run cliques(ig, min = 3) to find all cliques w/ >= 3 nodes 
  # and idenfity the maximal clique containing remained 
  # if no such a clique then the minimal edge cut to make node sim 
  # is the set of edges b/w nodea nd removed 
  allQ = cliques(ig, min = length(subset))
  qSizes = sapply(allQ, length)
  keep = rep(1, length(allQ))
  if (length(subset) > 0) {
    for (i in 1:length(allQ)) {
      if (prod(subset %in% names(allQ[[i]])) == 0) keep[i] = 0
    }
  }
  
  maxQSize = qSizes[max(which(keep == 1))]
  maxQList = allQ[keep == 1][which(qSizes[keep == 1] == maxQSize)]
  edgesCut = rep(list(NULL), length(maxQList))
  for (i in 1:length(maxQList)) {
    edgesCut[[i]] = c(edgesCut[[i]], xNbrs[!xNbrs %in% names(maxQList[[i]])])
  }
  return(edgesCut)
  
}
```


## 2nd version
```{r}
# check if a graph is wrs or not 
# steps:
# 4. find all simplicial nodes in g, sub_g := g
# 5.1. for each simplicial node x, sub_g := sub_g[X-x]
# 5.2*. find simplicial nodes in nbrs(x) in sub_g
# 6*. remove edge y-z if: 
# a. none of y and z is a simplicial node in either g or sub_g and,
# b. y-z doesn't belong to the neighbouring clique of a simplicial node in g or sub_g.  
# 7*. g = sub_g, go back to step 5.1 and repeat for another simplicial node in g, 
# 8. once all simplicial nodes in g have been considered, g := sub_g
# 9. go back to step 4
# termination criteria is not correct!
is_wrs = function(graph) {
  
  repeat {
    
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      
      wrs = 1
      break
      
    }
    
    # if the current graph is non-chordal, continue...
    # step 4:
    nodes = colnames(graph)
    nbrsList = lapply(nodes, find_nbr, graph = graph)
    names(nbrsList) = nodes
    simplicialNodes = find_simplicial(graph, nbrsList, nodes)
    subG = graph
    if (length(simplicialNodes) > 0) {
      
      # step 5.1:
      for (x in simplicialNodes) {# for each sim node x in graph
        
        subG = subgraph(subG, x)
        xNbrs = nbrsList[[which(nodes == x)]] 
        xNbrs = xNbrs[xNbrs %in% colnames(subG)]  # remove deleted nodes from xNbrs
        nonSim = c()
        
        # only check if x's nbrs are simplicial in subG if it has more than 1 nbr
        if (length(xNbrs) > 1) {
          
          # step 5.2: check simplicial of nbrs(x) in subG
          for (y in xNbrs) {# for each y in nbrs(x)
            yNbrs = nbrsList[[which(nodes == y)]]
            yNbrs = yNbrs[yNbrs != x] # remove x because x isn't in tempG
            yNbrs = yNbrs[yNbrs %in% colnames(subG)] # remove deleted nodes from yNbrs
            # check if y is a simplicial node in tempG
            if (!y %in% simplicialNodes) {# if y is non-sim in G...
              # ... and y is non-sim in subG, record it
              if (!is_simplicial(subG, y, yNbrs)) nonSim = c(nonSim, y)  
            }
          } # end of step 5.2
        
          # step 6:
          # remove edge y-z b/w non-simplicial nbrs in tempG if 
          # a. none of y and z is a simplicial node in either g or sub_g (checked in step 5.2) and,
          # b. y, z are not nbrs of another simplicial node in g or subG
          if (length(nonSim) > 1) {# only if there are at leat 2 non-sim nodes
            
            # find mutual nbrs b/w each pair of non-sim nodes in nbrs(x)
            for (i in 1:(length(nonSim) - 1)) {
              for (j in (i + 1):length(nonSim)) {
                
                safeToRemove = 1
                # check if their nbrs are sim nodes in either G or subG
                mutualNbrs = common_nbrs(subG, nonSim[i], nonSim[j]) 
                mutualNbrs = mutualNbrs[mutualNbrs != x] # remove x 
                mutualNbrs = mutualNbrs[mutualNbrs %in% colnames(subG)] # remove deleted nodes from mutualNbrs
                for (k in mutualNbrs) {
                  if (k %in% simplicialNodes) {# if k is sim in g
                    safeToRemove = 0
                    break
                  }
                  kInd = which(nodes == k)
                  kNbrs = nbrsList[[kInd]]
                  kNbrs = kNbrs[kNbrs %in% colnames(subG)]
                  if (is_simplicial(subG, k, kNbrs)) {# if k is sim in subG
                    safeToRemove = 0
                    break
                  }
                }# end for checking mutualNbrs
                
                if (safeToRemove) subG[nonSim[i], nonSim[j]] = subG[nonSim[j], nonSim[i]] = 0
                
              }
            }
            
          } # end of step 6
          
        } # end of step 5.2
        
      }# end of step 5.1 for each sim node x
      
      graph = subG # update graph
    
    } else if (length(simplicialNodes) < 1) {
      
      # if the current is non-chordal and has no simplicial node, then it isn't wrs
      wrs = 0
      break 
      
    }
    
  } # end repeat
  
  return(wrs)
  
}
```

# 3rd version (currently used)
```{r}
# check if a graph is wrs or not 
# steps:
# 4. find all simplicial nodes in g, sub_g := g
# 5.1. for each simplicial node x, sub_g := sub_g[X-x]
# 5.2*. find simplicial nodes in nbrs(x) in sub_g
# 6*. remove edge y-z if: 
# a. none of y and z is a simplicial node in either g or sub_g and,
# b. y-z doesn't belong to the neighbouring clique of a simplicial node in g or sub_g.  
# 7*. g = sub_g, go back to step 5.1 and repeat for another simplicial node in g, 
# 8. once all simplicial nodes in g have been considered, g := sub_g
# 9. go back to step 4
# termination criteria is not correct!
# 
# remove as fewer edges as possible
# by that i mean if delete a node x and its edges introduce another sim node y (y in nbrs(x)) in the subgraph, will y still be a sim node in subgraph if only remove partial edges of x
is_wrs3 = function(graph) {
  
  repeat {
    
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      
      wrs = 1
      break
      
    }
    
    # if the current graph is non-chordal, continue...
    # step 4:
    nodes = colnames(graph)
    nbrsList = lapply(nodes, find_nbr, graph = graph)
    names(nbrsList) = nodes
    simplicialNodes = find_simplicial(graph, nbrsList, nodes)
    if (length(simplicialNodes) > 0) {
      
      # order simplicial nodes by node degree ascending
      degrees = sapply(simplicialNodes, degree, graph = graph)
      simplicialNodes = simplicialNodes[order(degrees)]
      # step 5.1:
      #for (x in simplicialNodes) {# for each sim node x in graph
        x = simplicialNodes[1] # take the 1st simplicial node
        subG = subgraph(graph, x)
        xNbrs = nbrsList[[which(nodes == x)]] 
        #xNbrs = xNbrs[xNbrs %in% colnames(subG)]  # remove deleted nodes from xNbrs
        nonSim = c()
        
        # only check if x's nbrs are simplicial in subG if it has more than 1 nbr
        if (length(xNbrs) > 1) {
          
          # step 5.2: check simplicial of nbrs(x) in subG
          for (y in xNbrs) {# for each y in nbrs(x)
            yNbrs = nbrsList[[which(nodes == y)]]
            yNbrs = yNbrs[yNbrs != x] # remove x because x isn't in tempG
            #yNbrs = yNbrs[yNbrs %in% colnames(subG)] # remove deleted nodes from yNbrs
            # check if y is a simplicial node in tempG
            if (!y %in% simplicialNodes) {# if y is non-sim in G...
              # ... and y is non-sim in subG, record it
              if (!is_simplicial(subG, y, yNbrs)) nonSim = c(nonSim, y)  
            }
          } # end of step 5.2
        
          # step 6:
          # remove edge y-z b/w non-simplicial nbrs in tempG if 
          # a. none of y and z is a simplicial node in either g or sub_g (checked in step 5.2) and,
          # b. y, z are not nbrs of another simplicial node in g or subG
          if (length(nonSim) > 1) {# only if there are at leat 2 non-sim nodes
            
            # find mutual nbrs b/w each pair of non-sim nodes in nbrs(x)
            for (i in 1:(length(nonSim) - 1)) {
              for (j in (i + 1):length(nonSim)) {
                
                safeToRemove = 1
                # check if their nbrs are sim nodes in either G or subG
                mutualNbrs = common_nbrs(subG, nonSim[i], nonSim[j]) 
                mutualNbrs = mutualNbrs[mutualNbrs != x] # remove x 
                #mutualNbrs = mutualNbrs[mutualNbrs %in% colnames(subG)] # remove deleted nodes from mutualNbrs
                for (k in mutualNbrs) {
                  if (k %in% simplicialNodes) {# if k is sim in g
                    safeToRemove = 0
                    break
                  }
                  kInd = which(nodes == k)
                  kNbrs = nbrsList[[kInd]]
                  kNbrs = kNbrs[kNbrs != x]
                  #kNbrs = kNbrs[kNbrs %in% colnames(subG)]
                  if (is_simplicial(subG, k, kNbrs)) {# if k is sim in subG
                    safeToRemove = 0
                    break
                  }
                }# end for checking mutualNbrs
                
                if (safeToRemove) subG[nonSim[i], nonSim[j]] = subG[nonSim[j], nonSim[i]] = 0
                
              }
            }
            
          } # end of step 6
          
        } # end of step 5.2
        
      #}# end of step 5.1 for each sim node x
      
      graph = subG # update graph
    
    } else if (length(simplicialNodes) < 1) {
      
      # if the current is non-chordal and has no simplicial node, then it isn't wrs
      wrs = 0
      break 
      
    }
    
  } # end repeat
  
  return(wrs)
  
}
```

# 4th version
```{r}
# check if a graph is wrs or not 
# steps:
# 4. find all simplicial nodes in g, sub_g := g
# 5.1. for each simplicial node x, sub_g := sub_g[X-x]
# 5.2*. find simplicial nodes in nbrs(x) in sub_g
# 6*. remove edge y-z if there is no z != x s.t. xyz forms a 3-clique 
# 7*. g = sub_g, go back to step 5.1 and repeat for another simplicial node in g, 
# 8. once all simplicial nodes in g have been considered, g := sub_g
# 9. go back to step 4
# termination criteria is not correct!
# 
# remove as fewer edges as possible
# by that i mean if delete a node x and its edges introduce another sim node y (y in nbrs(x)) in the subgraph, will y still be a sim node in subgraph if only remove partial edges of x
is_wrs4 = function(graph) {
  
  repeat {
    
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      
      wrs = 1
      break
      
    }
    
    # if the current graph is non-chordal, continue...
    # step 4:
    nodes = colnames(graph)
    nbrsList = lapply(nodes, find_nbr, graph = graph)
    names(nbrsList) = nodes
    simplicialNodes = find_simplicial(graph, nbrsList, nodes)
    if (length(simplicialNodes) > 0) {
      
      # order simplicial nodes by node degree ascending
      degrees = sapply(simplicialNodes, degree, graph = graph)
      simplicialNodes = simplicialNodes[order(degrees)]
      # step 5.1:
      #for (x in simplicialNodes) {# for each sim node x in graph
        x = simplicialNodes[1] # take the 1st simplicial node
        subG = subgraph(graph, x)
        
        xNbrs = nbrsList[[which(nodes == x)]]
        if (length(xNbrs) > 1) {
          
          # sim = c()
          # # step 5.2: check simplicial of nbrs(x) in subG
          # for (y in xNbrs) {# for each y in nbrs(x)
          #   yNbrs = nbrsList[[which(nodes == y)]]
          #   yNbrs = yNbrs[yNbrs != x] # remove x because x isn't in tempG
          #   #yNbrs = yNbrs[yNbrs %in% colnames(subG)] # remove deleted nodes from yNbrs
          #   # check if y is a simplicial node in tempG
          #   if (!y %in% simplicialNodes) {# if y is non-sim in G...
          #     # ... and y is sim in subG, record it
          #     if (is_simplicial(subG, y, yNbrs)) sim = c(sim, y)  
          #   }
          # } # end of step 5.2
          #
          # if (length(sim) + length(simplicialNodes) < 2) {# if no sim node in subG
            m = matrix(0, choose(length(xNbrs), 2), 3)
            mInd = 1  
            for (i in 1:(length(xNbrs) - 1)) {
              y = xNbrs[i]
              ySImInSubG = is_simplicial(subG, y, find_nbr(subG, y))
              for (j in (i + 1):length(xNbrs)) {
                z = xNbrs[j]
                tempG = subG 
                tempG[y, z] = tempG[z, y] = 0
                ySimInTempG = is_simplicial(tempG, y, find_nbr(tempG, y))
                zSimInSubG = is_simplicial(subG, z, find_nbr(subG, z))
                zSimInTempG = is_simplicial(tempG, z, find_nbr(tempG, z))
                nNewSim = ySimInTempG + zSimInTempG - ySImInSubG - zSimInSubG 
                m[mInd, ] = c(y, z, nNewSim)
                mInd = mInd + 1
              }
            }
            if (max(as.numeric(m[, 3])) > 0) {
              maxInd = which.max(as.numeric(m[, 3]))
              y = m[maxInd, 1]
              z = m[maxInd, 2]
              subG[y, z] = subG[z, y] = 0
            }
          # } else {# if there is sim node in subG
          #   for (i in 1:(length(xNbrs) - 1)) {
          #     y = xNbrs[i]
          #     #yInd = which(nodes == y)
          #     for (j in (i + 1):length(xNbrs)) {
          #       z = xNbrs[j]
          #       #zInd = which(nodes == z)
          #       mutualNbrs = common_nbrs(subG, y, z)
          #       mutualNbrs = mutualNbrs[mutualNbrs != x] 
          #       mutualNbrs = mutualNbrs[!mutualNbrs %in% xNbrs]  
          #       if (length(mutualNbrs) < 1) subG[y, z] = subG[z, y] = 0
          #     }
          #   }
          # }
        }
      graph = subG # update graph
    
    } else if (length(simplicialNodes) < 1) {
      
      # if the current is non-chordal and has no simplicial node, then it isn't wrs
      wrs = 0
      break 
      
    }
    
  } # end repeat
  
  return(wrs)
  
}
```


## 5th version

```{r}
# check if a graph is wrs or not 
# steps:
# 4. find all simplicial nodes in g
# 5.0 order simplicial nodes by degree ascending
# 5.1. for simplicial node x that has the smallest degree, sub_g := sub_g[X-x]
# 5.2. check if nbrs(x) are simplcial nodes in sub_g
# 6. remove edge e = y-z if the removal of e change y, z from non-sim to sim
# i.e. if none or one of y and z is a sim before removing e but more are sim after removing
# 7. g = sub_g, go back to step 4
# stop: if the remaining graph is non-chordal and has no simplicial node
# new observation**: combination of edge removal from multiple simplicial nodes could result in more sim nodes, when non single node edge removal produces sim nodes!!!
is_wrs5 = function(graph, debug = F) {
  
  repeat {
    
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      
      wrs = 1
      break
      
    }
    
    # if the current graph is non-chordal, continue...
    # step 4:
    nodes = colnames(graph)
    nbrsList = lapply(nodes, find_nbr, graph = graph)
    names(nbrsList) = nodes
    simplicialNodes = find_simplicial(graph)
    if (length(simplicialNodes) > 0) {
  
      # step 5.1: find the node x w/ the smallest degree
      x = simplicialNodes[1]
      if (debug) cat("sim node:", x, "\n")
      subG = subgraph(graph, x, "nodes")
      xNbrs = nbrsList[[x]] 
      if (debug) cat("nbrs:", xNbrs, "\n")
      if (length(xNbrs) > 1) {
        
        # step 5.2: check simplicial of nbrs(x) in subG 
        xNbrsSimInSubG = are_simplicial(subG, xNbrs)
        
        # step 6: remove edge e = y-z if the removal of e change y, z from non-sim to sim
        # i.e. if none or one of y and z is a sim before removing e but more are sim after removing
        if (sum(xNbrsSimInSubG) < length(xNbrs)) {
          # remove all edges to check how many new sim could be produced
          tempG = subgraph(subG, xNbrs, "edges")
          xNbrsSimInTempG = are_simplicial(tempG, xNbrs)
          # if new sim nodes are introduced...
          if (sum(xNbrsSimInTempG) > sum(xNbrsSimInSubG)) {
            # ... remove corresponding edges
            newSim = xNbrs[which(xNbrsSimInTempG > xNbrsSimInSubG)]
            edges = edge_set(subG, xNbrs)
            #############################################
            for (i in 1:nrow(edges)) {
              tempGG = tempG
              tempGG[edges[i, 1], edges[i, 2]] = tempGG[edges[i, 2], edges[i, 1]] = 1
              if (prod(are_simplicial(tempGG, newSim))) {# if yes, add the edge
                tempG = tempGG
              }
            }
            if (debug) cat("remove edges: \n")
            if (debug) print(subG - tempG)
            subG = tempG
            # ... but only remove minimal edge set
            # toDeleteEdges = minimal_edge_removal(subG, xNbrs, newSim)
            # for (i in 1:nrow(toDeleteEdges)) {
            #   subG[toDeleteEdges[i, 1], toDeleteEdges[i, 2]] = 
            #     subG[toDeleteEdges[i, 2], toDeleteEdges[i, 1]] = 0
            # }
            # for (p in xNbrs) {
            #   for (q in xNbrs[xNbrs != p]) {
            #     if ((p %in% newSim) || (q %in% newSim)) subG[p, q] = 0 
            #   }
            # }# end for p
            #############################################
            
          }
        }
          
      } # end of step 5.2
    
      # step 7:
      graph = subG # update graph
      if (debug) cat("----------------------------- \n")
    } else if (length(simplicialNodes) < 1) {
      
      # if the current is non-chordal and has no simplicial node, then it isn't wrs
      wrs = 0
      break 
      
    }
    
  } # end repeat
  
  return(wrs)
  
}
```

# 6th version
```{r}
# steps:
# 3. find nbrsList for all nodes
# 4. find all sim nodes in G
# 5. remove all sim nodes simultaneously and update 
#    subG = G[X - sim]
# 7. list all nbrs of the removed sims
# 8. for each nbr y, find the minimal edge set, removing which y becomes sim 
#    the edge set could be empty, which implies either y is a sim or no way to be a sim
#    for some node, there maybe more than one set of edges to make it a sim
#    in the end we want a collection of edges to be as small as possible 
#    but keep all nodes connected (i.e., no isolated nodes) 
# 9. remove the minimal edge sets,
#    G = subG and back to step 4
is_wrs6 = function(graph, debug = F) {
  
  repeat {
    
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      wrs = 1
      break
    }
    
    # if the current graph is non-chordal, continue...
    # step 3: find nbrsList for all nodes
    # nodes = colnames(graph)
    # nbrsList = lapply(nodes, find_nbr, graph = graph)
    # names(nbrsList) = nodes
    # step 4: find all sim nodes in graph
    simInG = find_simplicial(graph)
    
    if (length(simInG) > 0) {
  
      if (debug) cat("sim nodes:", simInG, "\n")
      
      # step 5: remove all sim nodes simultaneously 
      subG = subgraph(graph, simInG, "nodes") # update subG
      
      # step 6.1: list all nbrs in G of the removed sim nodes
      simNbrsList = lapply(simInG, find_nbr, graph = graph)
      names(simNbrsList) = simInG
      
      # step 6.2: for each nbr y, find its nbr in subG from simNbrsList
      selectedNodes = unique(unlist(simNbrsList))
      # remove those sim nodes that have been removed
      selectedNodes = selectedNodes[!selectedNodes %in% simInG]
      selectedNodesNbrsList = rep(list(NULL), length(selectedNodes))
      for (i in 1:length(selectedNodes)) {
        x = selectedNodes[i]
        for (j in 1:length(simNbrsList)) {
          if ((x %in% simNbrsList[[j]]) && (length(simNbrsList[[j]]) > 1)) {
            xPartialNbrs = simNbrsList[[j]] 
            xPartialNbrs = xPartialNbrs[xPartialNbrs != x] # remove x
            # remove all sim nodes that have been removed 
            xPartialNbrs = xPartialNbrs[!xPartialNbrs %in% simInG] 
            selectedNodesNbrsList[[i]] = 
              c(selectedNodesNbrsList[[i]], xPartialNbrs)
          }
        }
      }
      selectedNodesNbrsList = lapply(selectedNodesNbrsList, unique)
      names(selectedNodesNbrsList) = selectedNodes
      #l = c()
      totalEdgesCut = data.frame()
      # step 7.1: for each non-sim node y in selectedNodes, check if it has the potential 
      # to be a sim by removing all its nbrs in selectedNodesNbrsList
      for (x in selectedNodes) {
        if ((length(selectedNodesNbrsList[[x]]) > 0) && (!is_simplicial(subG, x))) {
          # remove all its nbrs from selectedNodesNbrsList
          tempG = subG
          tempG[x, selectedNodesNbrsList[[x]]] = tempG[selectedNodesNbrsList[[x]], x] = 0
          if (is_simplicial(tempG, x)) {
            xTotalNbrs = names(which(subG[x, ] == 1))
            xOtherNbrs = xTotalNbrs[!xTotalNbrs %in% selectedNodesNbrsList[[x]]]
            eCut = minimal_edges_cut(subG, x, xTotalNbrs, xOtherNbrs)
            
            # there maybe cases with more than one set of edges cut for a node
            # in this case select the set that makes the entire edges cut set minimal
            # if no unique solution, then pick the 1st set
            # if only one set then proceed...
            #if (length(eCut) == 1) {
              #cat(length(eCut), "\n")
              for (y in unlist(eCut[[1]])) {
                e = c(x, y)
                e = e[order(e)]
                # only bind non-existence edges
                if (is.na(row.match(e, totalEdgesCut))) {
                  totalEdgesCut = rbind(totalEdgesCut, e, stringsAsFactors = F)  
                }
              }
            #} else {# otherwise...
              
              #cat("error!")
            #}
          }
        }
      }
      
      # step 7.2: remove edges from subG
      if (nrow(totalEdgesCut) > 0) {
        for (i in 1:nrow(totalEdgesCut)) {
          subG[totalEdgesCut[i, 1], totalEdgesCut[i, 2]] = 
            subG[totalEdgesCut[i, 2], totalEdgesCut[i, 1]] = 0
          if (is_chordal(subG)) {
            wrs = 1
            break
          }
        }
      }
      
      # step 8:
      graph = subG # update graph
      
    } else {# if graph is non-chordal and has no sim nodes 
      
      wrs = 0
      break 
      
    }
    
  } # end repeat
  
  return(wrs)
  
}
```

# 7th version
```{r}
# steps:
# 3. find nbrsList for all nodes
# 4. find all sim nodes in G
# 5. remove all sim nodes simultaneously and update 
#    subG = G[X - sim]
# 7. list all nbrs of the removed sims
# 8. for each nbr y, find the minimal edge set, removing which y becomes sim 
#    the edge set could be empty, which implies either y is a sim or no way to be a sim
#    for some node, there maybe more than one set of edges to make it a sim
#    in the end we want a collection of edges to be as small as possible 
#    but keep all nodes connected (i.e., no isolated nodes) 
# 9. remove the minimal edge sets,
#    G = subG and back to step 4
is_wrs7 = function(graph, debug = F) {
  
  # cach all edges b/w nbrs of sim nodes
  # exist duplicated edges, fixed it!!!
  cachedEdges = data.frame(stringsAsFactors = F)
  repeat {
    # stop if the current graph is chordal
    if (is_chordal(graph)) {
      wrs = 1
      break
    }
    
    simInG = find_simplicial(graph)
    if (debug) cat("sim:", simInG, "\n")
    if (length(simInG) > 0) {
      subG = subgraph(graph, simInG, "nodes") # update subG
      simNbrsList = lapply(simInG, find_nbr, graph = graph)
      names(simNbrsList) = simInG
      selectedNodes = unique(unlist(simNbrsList))
      selectedNodes = selectedNodes[!selectedNodes %in% simInG]
      selectedNodesNbrsList = rep(list(NULL), length(selectedNodes))
      cachedEdgesTemp = data.frame(stringsAsFactors = F)
      for (i in 1:length(selectedNodes)) {
        x = selectedNodes[i]
        for (j in 1:length(simNbrsList)) {
          if ((x %in% simNbrsList[[j]]) && (length(simNbrsList[[j]]) > 1)) {
            xPartialNbrs = simNbrsList[[j]] 
            xPartialNbrs = xPartialNbrs[xPartialNbrs != x] # remove x
            # remove all sim nodes that have been removed 
            xPartialNbrs = xPartialNbrs[!xPartialNbrs %in% simInG] 
            if (length(xPartialNbrs) > 0) {
              cachedEdgesTemp = rbind(cachedEdgesTemp, data.frame(from = x, to = xPartialNbrs, stringsAsFactors = F))
              selectedNodesNbrsList[[i]] = c(selectedNodesNbrsList[[i]], xPartialNbrs)
            }
          }
        }
      }
      
      selectedNodesNbrsList = lapply(selectedNodesNbrsList, unique)
      names(selectedNodesNbrsList) = selectedNodes
      cachedEdgesTemp = remove_df_duplicated_with_no_order(cachedEdgesTemp)
      cachedEdges = rbind(cachedEdges, cachedEdgesTemp)
      cachedEdges = remove_df_duplicated_with_no_order(cachedEdges)
      # remove minimal edges cut one by one
    
      # step 7.1: for each non-sim node y in selectedNodes, check if it has the potential 
      # to be a sim by removing all its nbrs in selectedNodesNbrsList
      for (x in selectedNodes) {
        if ((x %in% c(t(cachedEdges))) && (!is_simplicial(subG, x))) {
          # remove all its nbrs from selectedNodesNbrsList
          tempG = subG
          # a vector of nodes that have formed a clique with x so far
          Y = selectedNodesNbrsList[[x]]
          Y = c(Y, c(t(cachedEdges[apply(cachedEdges, 1, is.element, el = x), ])))
          Y = unique(Y)
          Y = Y[Y != x]
          Y = Y[Y %in% colnames(tempG)]
          tempG[x, Y] = tempG[Y, x] = 0
          if (is_simplicial(tempG, x)) {
            xTotalNbrs = names(which(subG[x, ] == 1))
            xOtherNbrs = xTotalNbrs[!xTotalNbrs %in% Y]
            eCut = minimal_edges_cut(subG, x, xTotalNbrs, xOtherNbrs)
            if (length(eCut) > 1) {
              eCut = eCut[which.max(sapply(eCut, length))]
            }
            # there maybe cases with more than one set of edges cut for a node
            # in this case select the set that makes the entire edges cut set minimal
            # if no unique solution, then pick the 1st set
            # if only one set then proceed...
            #if (length(eCut) == 1) {
            #cat(length(eCut), "\n")
              
            if (debug) cat(x, "-", unlist(eCut), "\n")
            for (y in unlist(eCut)) {
              subG[x, y] = subG[y, x] = 0
              e = c(x, y)
              e = e[order(e)]
              ind = row.match(e, cachedEdges)
              if (!is.na(ind)) {
                cachedEdges = cachedEdges[-ind, ]
              }
            }
          }
            #} else {# otherwise...
              
              #cat("error!")
            #}
        } 
      }
      
      
      # step 8:
      graph = subG # update graph
      
    } else {# if graph is non-chordal and has no sim nodes 
      
      wrs = 0
      break 
      
    }
    if (debug) cat("----------------------- \n")
  } # end repeat
  
  return(wrs)
  
}
```














