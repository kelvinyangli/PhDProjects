---
title: "mml_rand_str"
author: "kl"
date: "6 January 2018"
output: pdf_document
---

```{r setup, include=FALSE}
# dag = empty.graph(c("V1", "V7", "V9", "V10"))
# dag = set.arc(dag, "V1", "V7")
# #dag = set.arc(dag, "V1", "V9")
# #dag = set.arc(dag, "V1", "V10")
# dag = set.arc(dag, "V7", "V9")
# dag = set.arc(dag, "V7", "V10")
# #dag = set.arc(dag, "V9", "V10")
dag = randDag(10, 2)
cpts = randCPTs(dag, 2, 1)
n = 100
data = rbn(cpts, n)
vars = colnames(data)
arities = sapply(data, nlevels)
names(arities) = c()
graphviz.plot(dag)
```

```{r}
# a function to calculate the log of probability according to a pre-cal prob table and data
log_score = function(data, adptProbs, targetIndex, n) {
  
  logScore = 0  
  for (i in 1:n) {
    
    targetValue = as.numeric(data[i, targetIndex])
    logScore = logScore + log(adptProbs[targetValue, i])
      
  }
  
  return(logScore)
  
}

adpt_code_prob_no_pa = function(data, arities, xIndex, n) {
  
  probs = matrix(0.5, arities[xIndex], n)
  cnt = rep(1, arities[xIndex]) # initializing cnt with 1
  for (i in 1:(nrow(data) - 1)) {
    
    xValue = as.numeric(data[i, xIndex])
    cnt[xValue] = cnt[xValue] + 1 # updating cnt
    probs[, i + 1] = cnt / sum(cnt)
    
  }
  
  return(probs)
  
}


adpt_code_prob = function(data, arities, xIndex, yIndices, targetIndex, n) {
  
  probs = matrix(0.5, arities[targetIndex], n) 
  cnt = rep(1, arities[xIndex]) # initializing cnt with 1
  for (i in yIndices) {
    
    # make a high-dim list to store cnt
    # each lvl in the list corresponds to a value of one parent of x
    cnt = rep(list(cnt), arities[i])
    
  }
  
  for (i in 1:(nrow(data) - 1)) {# start adaptive counting for each data point
  
    indices = as.numeric(data[i, c(yIndices, xIndex)])
    cnt[[matrix(indices, 1)]] = cnt[[matrix(indices, 1)]] + 1 # updating cnt
    indices = as.numeric(data[i + 1, c(yIndices, xIndex)]) # computing prob from 2nd data point
    for (k in 1:arities[targetIndex]) {# loop throughe each value of the target 
      
      indices[which(c(yIndices, xIndex) == targetIndex)] = k
      probs[k, i + 1] = cnt[[matrix(indices, 1)]] / sum(cnt[[matrix(indices[-length(indices)], 1)]])
      
    }
    
  } # end adaptive counting
  
  return(probs)
  
}

# check f when there is a sp
mml_rand_str = function(str, data, vars, arities, targetIndex, n) {

  tempVars = bnlearn::nodes(str)
  logScore = 0 
  margProbs = matrix(1, arities[targetIndex], n)
  for (x in tempVars) {
    
    # if it is the target or it has at least one parent,  
    # then get the adaptive count of it given its parent set
    xIndex = which(vars == x)
    pa = bnlearn::parents(str, x)
    paIndices = which(vars %in% pa)
    
    if (length(pa) > 0) {
      
      adptProbs = adpt_code_prob(data, arities, xIndex, paIndices, targetIndex, n)
      logScore = logScore + log_score(data, adptProbs, targetIndex, n)
      margProbs = margProbs * adptProbs
    
    } else if (x == vars[targetIndex]) {
      
      adptProbs = adpt_code_prob_no_pa(data, arities, xIndex, n)
      logScore = logScore + log_score(data, adptProbs, targetIndex, n)
      margProbs = margProbs * adptProbs
      
    }
        
  }
  
  return(-(logScore - sum(log(apply(margProbs, 2, sum)))))
  
}

```

```{r}
# this code doesn't calculate the msg len of T|V1,V2 right, where V1 and V2 are both parents of T
# step 1: identify vars
# step 2: sample a random str over the identified vars
# step 3: identify the parent set of each var
# step 4: get adaptive count of each var given its parent set

str = empty.graph(c("T", "V1", "V2","V3"))
str = set.arc(str, "V1", "T")
str = set.arc(str, "V3", "V2")
str = set.arc(str, "T", "V2")

di = count_occurance(data, arities)
# mml_cpt(di, arities, n, c(2, 3,4), 1, base = exp(1))
# mml_nb_adaptive(data, arities, 1, c(2, 3,4))
```

```{r}
di = count_occurance(data, arities)
target = "V5"
targetIndex = which(vars == target)
unchecked = vars[vars != target]
cmb = c()
#min_l = mml_cpt(di, arities, n, c(), targetIndex, base = exp(1))
min_l = mml_nb_adaptive(data, arities, targetIndex, c())
cat(min_l, "\n")
```

```{r}
# this code can be speed up by calculating probs(target) once and re-use it 
# since the only case we cal the probs of a node that has no parents is when this node is the target
# inf appear in mml score due to rounding error, fixed by removing round to 2nd digit
# hardly add the 2nd var after 1st is added, identify problem
temp_l = c()
for (x in unchecked) {
  
  tempVars = c(cmb, x, target)
  mbpts = readRDS(paste0("~/Documents/PhDProjects/RStudioProjects/local2global/MBPTs/", length(tempVars) - 1, ".rds"))
  l = 0 
  for (i in 1:length(mbpts)) {
    
    pt = mbpts[[i]]
    dimnames(pt) = rep(list(tempVars), 2)
    pt = matrix2dag(pt)
    pa = bnlearn::parents(pt, target)
    ch = bnlearn::children(pt, target)
    if (length(pa) == (length(tempVars) - 1)) {
      
      res = mml_cpt(di, arities, n, which(vars %in% pa), targetIndex, base = exp(1))        
      l = l + res
      #cat(res, "\n")
    } else if (length(ch) == (length(tempVars) - 1)) {
      
      res = mml_nb_adaptive(data, arities, targetIndex, which(vars %in% ch))
      l = l + res
      #cat(res, "\n")
    } else {
      
      res = mml_rand_str(pt, data, vars, arities, targetIndex, n)
      l = l + res
      #cat(res, "\n")
    }
    #cat(l, "\n")
  }
  
  avg_l = l / length(mbpts)
  cat(c(cmb, x), "--", avg_l, "\n")
  
  temp_l = c(temp_l, avg_l)
  local_min_l = min(temp_l)
  
}

if (min_l > local_min_l) {
    
  toadd = unchecked[which.min(temp_l)]
  cmb = c(cmb, toadd)
  cat("cmb:", cmb, "\n")
  unchecked = unchecked[-which.min(temp_l)]
  cat("unchked", unchecked, "\n")
  min_l = local_min_l
    
}


```
```{r}
# check when single target with no other nodes, why don't mml_cpt = mml_nb?
# the problem of mml_cpt is the approx of log(factorial)
# use adpt code method for cpt, should increase acc 
forward_greedy_fast(data, di, arities, n, target, debug = F)
forward_greedy(data, arities, vars, n, target, mml_nb_adaptive, debug = F)
```


