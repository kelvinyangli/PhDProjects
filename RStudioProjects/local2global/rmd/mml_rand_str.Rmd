---
title: "mml_rand_str"
author: "kl"
date: "6 January 2018"
output: pdf_document
---

```{r setup, include=FALSE}
# dag = empty.graph(c("V1", "V7", "V9", "V10"))
# dag = set.arc(dag, "V1", "V7")
# #dag = set.arc(dag, "V1", "V9")
# #dag = set.arc(dag, "V1", "V10")
# dag = set.arc(dag, "V7", "V9")
# dag = set.arc(dag, "V7", "V10")
# #dag = set.arc(dag, "V9", "V10")
graphviz.plot(dag)
```

```{r}
# a function to calculate the log of probability according to a pre-cal prob table and data
log_score = function(data, adptProbs, targetIndex, n) {
  
  logScore = 0  
  for (i in 1:n) {
    
    targetValue = as.numeric(data[i, targetIndex])
    logScore = logScore + log(adptProbs[targetValue, i])
      
  }
  
  return(logScore)
  
}

adpt_code_prob_no_pa = function(data, arities, xIndex, n) {
  
  probs = matrix(0.5, arities[xIndex], n)
  cnt = rep(1, arities[xIndex]) # initializing cnt with 1
  for (i in 1:(nrow(data) - 1)) {
    
    xValue = as.numeric(data[i, xIndex])
    cnt[xValue] = cnt[xValue] + 1 # updating cnt
    probs[, i + 1] = cnt / sum(cnt)
    
  }
  
  return(probs)
  
}


adpt_code_prob = function(data, arities, xIndex, yIndices, targetIndex, n) {
  
  probs = matrix(0.5, arities[targetIndex], n) 
  cnt = rep(1, arities[xIndex]) # initializing cnt with 1
  for (i in rev(yIndices)) {
    
    # make a high-dim list to store cnt
    # each lvl in the list corresponds to a value of one parent of x
    cnt = rep(list(cnt), arities[i])
    
  }
  
  for (i in 1:(nrow(data) - 1)) {# start adaptive counting for each data point
  
    indices = as.numeric(data[i, c(yIndices, xIndex)])
    cnt[[matrix(indices, 1)]] = cnt[[matrix(indices, 1)]] + 1 # updating cnt
    indices = as.numeric(data[i + 1, c(yIndices, xIndex)]) # computing prob from 2nd data point
    for (k in 1:arities[targetIndex]) {# loop throughe each value of the target 
      
      indices[which(c(yIndices, xIndex) == targetIndex)] = k
      probs[k, i + 1] = cnt[[matrix(indices, 1)]] / sum(cnt[[matrix(indices[-length(indices)], 1)]])
      
    }
    
  } # end adaptive counting
  
  return(probs)
  
}

# check f when there is a sp
mml_rand_str = function(str, data, vars, arities, targetAdptProbs, targetIndex, n) {

  tempVars = bnlearn::nodes(str)
  logScore = 0 
  margProbs = matrix(1, arities[targetIndex], n)
  for (x in tempVars) {
    
    # if it is the target or it has at least one parent,  
    # then get the adaptive count of it given its parent set
    xIndex = which(vars == x)
    pa = bnlearn::parents(str, x)
    paIndices = which(vars %in% pa)
    
    if (length(pa) > 0) {
      
      adptProbs = adpt_code_prob(data, arities, xIndex, paIndices, targetIndex, n)
      logScore = logScore + log_score(data, adptProbs, targetIndex, n)
      margProbs = margProbs * adptProbs
    
    } else if (x == vars[targetIndex]) {
      
      logScore = logScore + log_score(data, targetAdptProbs, targetIndex, n)
      margProbs = margProbs * targetAdptProbs
      
    }
        
  }
  
  return(-(logScore - sum(log(apply(margProbs, 2, sum)))))
  
}

# this code can be speed up by calculating probs(target) once and re-use it 
# since the only case we cal the probs of a node that has no parents is when this node is the target
# inf appear in mml score due to rounding error, fixed by removing round to 2nd digit
# hardly add the 2nd var after 1st is added, identify problem
f = function(data, di, arities, vars, target, n, debug = FALSE) {
  
  targetIndex = which(vars == target)
  targetAdptProbs = adpt_code_prob_no_pa(data, arities, targetIndex, n)
  unchecked = vars[vars != target]
  cmb = c()
  #min_l = mml_cpt(di, arities, n, c(), targetIndex, base = exp(1))
  min_l = mml_nb_adaptive(data, arities, targetIndex, c())
  if (debug) cat(min_l, "\n")
  repeat {
    
    temp_l = c()
    for (x in unchecked) {
      
      tempVars = c(cmb, x, target)
      mbpts = readRDS(paste0("~/Documents/PhDProjects/RStudioProjects/local2global/MBPTs_ordered/", length(tempVars) - 1, ".rds"))
      l = 0 
      #l = rep(0, length(mbpts))
      for (i in 1:length(mbpts)) {
        
        pt = mbpts[[i]]
        dimnames(pt) = rep(list(tempVars), 2)
        pt = matrix2dag(pt)
        pa = bnlearn::parents(pt, target)
        ch = bnlearn::children(pt, target)
        if (length(pa) == (length(tempVars) - 1)) {
          
          res = mml_cpt(di, arities, n, which(vars %in% pa), targetIndex, base = exp(1))        
          if (debug) cat(i, res, "\n")
        } else if (length(ch) == (length(tempVars) - 1)) {
          
          res = mml_nb_adaptive(data, arities, targetIndex, which(vars %in% ch))
          if (debug) cat(i, res, "\n")
        } else {
          
          res = mml_rand_str(pt, data, vars, arities, targetAdptProbs, targetIndex, n)
          if (debug) cat(i, res, "\n")
        }
        l = l + res
        #l[i] = res
        #cat(l, "\n")
      }
      
      avg_l = l / length(mbpts)
      #avg_l = min(l)
      if (debug) cat(c(cmb, x), "--", avg_l, "\n")
      
      temp_l = c(temp_l, avg_l)
      local_min_l = min(temp_l)
      
    }
    
    if (min_l > local_min_l) {
        
      toadd = unchecked[which.min(temp_l)]
      cmb = c(cmb, toadd)
      if (debug) cat("cmb:", cmb, "\n")
      unchecked = unchecked[-which.min(temp_l)]
      if (debug) cat("unchked", unchecked, "\n")
      min_l = local_min_l
        
    }
    
    if ((length(unchecked) < 1) || (local_min_l > min_l)) break
    
  }

  if (length(cmb) < 1) cmb = character(0)
  return(cmb)

}

```

```{r}
dag = randDag(5, 2)
cpts = randCPTs(dag, 2, 1)
n = 50
data = rbn(cpts, n)
# data = read.csv("~/Documents/Experiments/UAI_exp/")
# data = numeric2categorical(data)
# n = nrow(data)
vars = colnames(data)
arities = sapply(data, nlevels)
names(arities) = c()
di = count_occurance(data, arities)

i = 1
lrand = lcpt = lnb = list()
for (target in vars) {
  
  #cat(i, "\n")
  targetIndex = which(vars == target)
  targetAdptProbs = adpt_code_prob_no_pa(data, arities, targetIndex, n)
  lrand[[i]] = forward_greedy(data, arities, vars, n, target, "random", varCnt = di, 
                              targetAdptProbs = targetAdptProbs, debug = T)
  #f(data, di, arities, vars, target, n, debug = T) 
  lcpt[[i]] = forward_greedy_fast(data, di, arities, n, target, debug = F)
  lnb[[i]] = forward_greedy(data, arities, vars, n, target, "nb", debug = F)
  i = i + 1
  
}

i = 1
arand = acpt = anb = rep(0, length(vars))
crand = ccpt = cnb = matrix(0, length(vars), 2)
m = p = c = s = 0
for (target in vars) {
  
  mbTrue = bnlearn::mb(dag, target)
  m = m + length(mbTrue)
  p = p + length(bnlearn::parents(dag, target))
  c = c + length(bnlearn::children(dag, target))
  s = s + (length(mbTrue) - length(bnlearn::parents(dag, target)) - length(bnlearn::children(dag, target)))
  arand[i] = mbEditDist(mbTrue, lrand[[i]], target, vars)
  crand[i, ] = classfication_accuracy_mb(mbTrue, lrand[[i]], vars, target)
  acpt[i] = mbEditDist(mbTrue, lcpt[[i]], target, vars)
  ccpt[i, ] = classfication_accuracy_mb(mbTrue, lcpt[[i]], vars, target)
  anb[i] = mbEditDist(mbTrue, lnb[[i]], target, vars)
  cnb[i, ] = classfication_accuracy_mb(mbTrue, lnb[[i]], vars, target)
  i = i + 1
  
}

nvars = length(vars)
#graphviz.plot(dag)
cat("stats: \n")
cat("m=", m/nvars, "; p=", p/nvars, "; c=", c/nvars, "; s=", s/nvars, "\n")
cat("rand str:", mean(arand), "+/-", 1.96 * sd(arand) / sqrt(n), "\n")
cat("cpt:", mean(acpt), "+/-", 1.96 * sd(acpt) / sqrt(n), "\n")
cat("nb:", mean(anb), "+/-", 1.96 * sd(anb) / sqrt(n), "\n")
cat("---------------------- \n")
cat(apply(crand, 2, mean), 2 * prod(apply(crand, 2, mean)) / sum(apply(crand, 2, mean)), "\n")
cat(apply(ccpt, 2, mean), 2 * prod(apply(ccpt, 2, mean)) / sum(apply(ccpt, 2, mean)), "\n")
cat(apply(cnb, 2, mean), 2 * prod(apply(cnb, 2, mean)) / sum(apply(cnb, 2, mean)), "\n")
cat("---------------------- \n")
# also report how many 100% mb discovery 


```


```{r}
# check when single target with no other nodes, why don't mml_cpt = mml_nb?
# the problem of mml_cpt is the approx of log(factorial)
# use adpt code method for cpt, should increase acc 
forward_greedy_fast(data, di, arities, n, target, debug = F)
forward_greedy(data, arities, vars, n, target, mml_nb_adaptive, debug = F)
```


