---
title: "Mini_expriments"
author: "kl"
date: "6 February 2018"
output: html_document
---

```{r global_options, include=F, warning=F, eval=F, echo=F, message=F}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE, echo = F, eval = T)
if (.Platform$OS.type == "windows") {
  dir = "C:/Users/"
} else {
  dir = "/home/"
}
source(paste0(dir, "kl/Documents/PhDProjects/RStudioProjects/local2global/scripts/load_libraries.R"))

# cpt = read.dsc("~/Downloads/barley.dsc.gz")
# a = c()
# for (i in 1:length(cpt)) {
#   a = c(a, nrow(cpt[[i]]$prob))
# }
# saveRDS(a, "~/Documents/Experiments/UAI_exp/barley/arities.rds")
```


```{r}
sd = randSeed()
set.seed(sd)
dag = randDag(10, 3)
graphviz.plot(dag)

vars = bnlearn::nodes(dag)
target = "V9"
targetIndex = 2
mbIndices = c(1, 3, 5)

str1 = matrix(0, 4, 4)
dimnames(str1) = rep(list(vars[c(mbIndices, targetIndex)]), 2)
str1[1,c(2,3,4)]=str1[4,c(2,3)]=1
str2 = str1
str2[1,c(2,3)]=0
ind = c()
for (k in 1:100) {
  
cpts = randCPTs(dag, 4, 1)
sampleSize = 1000
data = rbn(cpts, sampleSize)
vars = colnames(data)
nvars = ncol(data)
arities = sapply(data, nlevels)
di=count_occurance(data,arities)
data = data.matrix(data)
probsMtx = matrix(0.5, arities[targetIndex], sampleSize)
cachInd = 1
cachedPXGivenY = cachedPXGivenT = list() # empty list to cach condProbsAdpt calculated by mml_fixed_str_adaptive()

#forward_greedy(data,arities,vars,sampleSize,"T","random",varCnt = di,prior="uniform",debug=T)

for (i in 1:nvars) {

  if (i == targetIndex) {

    cachedPXGivenT[[i]] = probs_adaptive(data, arities, sampleSize, probsMtx, targetIndex)

  } else {

    cachedPXGivenT[[i]] = cond_probs_adaptive(data, arities, sampleSize, targetIndex, probsMtx, i, targetIndex)

  }

}

logProbTarget = sum(log(t(cachedPXGivenT[[targetIndex]])[cbind(seq_along(data[, targetIndex]), data[, targetIndex])]))

str1 = str
lp = logProbTarget # log probability
margProbs = cachedPXGivenT[[targetIndex]]
for (curIndex in mbIndices) {
  curPa = which(str1[, vars[curIndex]] == 1)
  curPaIndices = which(vars %in% names(curPa))
  #curPaIndices = c(mbIndices, targetIndex)[curPa]
  if (length(curPaIndices) > 0) {
    condProbsAdpt = cond_probs_adaptive(data, arities, sampleSize, targetIndex, probsMtx, curIndex, curPaIndices)
    temp = sum(log(t(condProbsAdpt)[cbind(seq_along(data[, targetIndex]), data[, targetIndex])]))
    lp = lp + temp
    cat(curIndex, "-", curPaIndices, "-", temp, "\n")
    margProbs = margProbs * condProbsAdpt
  }
}
-(lp - sum(log(apply(margProbs, 2, sum)))) # log(p(T|Xs))
  

str2 = str1
str2[1,4] = 0
lp = logProbTarget # log probability
margProbs = cachedPXGivenT[[targetIndex]]
for (curIndex in mbIndices) {
  curPa = which(str2[, vars[curIndex]] == 1)
  curPaIndices = which(vars %in% names(curPa))
  #curPaIndices = c(mbIndices, targetIndex)[curPa]
  if (length(curPaIndices) > 0) {
    condProbsAdpt = cond_probs_adaptive(data, arities, sampleSize, targetIndex, probsMtx, curIndex, curPaIndices)
    temp = sum(log(t(condProbsAdpt)[cbind(seq_along(data[, targetIndex]), data[, targetIndex])]))
    lp = lp + temp
    cat(curIndex, "-", curPaIndices, "-", temp, "\n")
    margProbs = margProbs * condProbsAdpt
  }
}
-(lp - sum(log(apply(margProbs, 2, sum)))) # log(p(T|Xs))

cat(l1, "-", l2, "\n")
ind = c(ind, which.min(c(l1, l2)))

}
```


```{r}
# sd = randSeed()
# set.seed(sd)


cc = 0
for (kk in 1:100) {
  
repeat {
dag = randDag(10, 3)
vars = bnlearn::nodes(dag)
mbtl = sapply(vars, bnlearn::mb, x = dag)
target = names(which(sapply(mbtl, length) == 9))[1]
if (!is.na(target)) break
}
  
#graphviz.plot(dag)
cpts = randCPTs(dag, 4, 1)
#target = "V8"
sampleSize = n = 100
data = rbn(cpts, n)
vars = colnames(data)
nvars = ncol(data)
arities = sapply(data, nlevels)
names(arities) = c()
varCnt = count_occurance(data,arities)
data = data.matrix(data)
targetIndex = which(vars == target)
probsMtx = matrix(0.5, arities[targetIndex], sampleSize)
mbt = bnlearn::mb(dag, target)
mbIndices = which(vars %in% mbt)

#forward_greedy(data,arities,vars,sampleSize,target,"random",varCnt = varCnt,prior="uniform",dag = dag, debug=T)

cachInd = 1
cachedPXGivenY = cachedPXGivenT = list() # empty list to cach condProbsAdpt calculated by mml_fixed_str_adaptive()
for (i in 1:nvars) {
  if (i == targetIndex) {
    cachedPXGivenT[[i]] = probs_adaptive(data, arities, sampleSize, probsMtx, targetIndex)
  } else {
    cachedPXGivenT[[i]] = cond_probs_adaptive(data, arities, sampleSize, targetIndex, probsMtx, i, targetIndex)
  }
}

logProbTarget = sum(log(t(cachedPXGivenT[[targetIndex]])[cbind(seq_along(data[, targetIndex]), data[, targetIndex])]))
lp = logProbTarget # log probability
margProbs = cachedPXGivenT[[targetIndex]]

str = local_extraction(dag, c(target, mbt))
str = dag2matrix(str)
for (curIndex in mbIndices) {
  curPa = which(str[, vars[curIndex]] == 1)
  curPaIndices = which(vars %in% names(curPa))
  if (length(curPaIndices) > 0) {
    condProbsAdpt = cond_probs_adaptive(data, arities, sampleSize, targetIndex, probsMtx, curIndex, curPaIndices)
    temp = sum(log(t(condProbsAdpt)[cbind(seq_along(data[, targetIndex]), data[, targetIndex])]))
    lp = lp + temp
    margProbs = margProbs * condProbsAdpt
  }
}
l1 = -(lp - sum(log(apply(margProbs, 2, sum))))

## random mb model
mbr = rand_mb_model(target, mbt)
for (curIndex in mbIndices) {
  curPa = which(mbr[, vars[curIndex]] == 1)
  curPaIndices = which(vars %in% names(curPa))
  if (length(curPaIndices) > 0) {
    condProbsAdpt = cond_probs_adaptive(data, arities, sampleSize, targetIndex, probsMtx, curIndex, curPaIndices)
    temp = sum(log(t(condProbsAdpt)[cbind(seq_along(data[, targetIndex]), data[, targetIndex])]))
    lp = lp + temp
    margProbs = margProbs * condProbsAdpt
  }
}
l2 = -(lp - sum(log(apply(margProbs, 2, sum))))

cat(l1, ":", l2, "\n")
if ((l1 < l2) || (l1 == l2)) cc = cc + 1
}
cc
```


## mml scores for strs in the same equivalent class
```{r}
s1 = empty.graph(c("V1", "V2", "T"))
s1 = set.arc(s1, "V2", "T")
s1 = set.arc(s1, "T", "V1")

s2 = empty.graph(c("V1", "V2", "T"))
s2 = set.arc(s2, "V1", "T")
s2 = set.arc(s1, "T", "V2")

s3 = empty.graph(c("V1", "V2", "T"))
s3 = set.arc(s3, "T", "V1")
s3 = set.arc(s3, "T", "V2")

vars = c("V1", "V2", "T")
arities = rep(2, 3) 
# suppose true model is one of the them
cpts = randCPTs(s1, 2, 1)
n = sampleSize = 100
data = rbn(cpts, n)
targetIndex = 3

probsMtx = matrix(0.5, arities[targetIndex], sampleSize)
cachInd = 1
cachedPXGivenY = cachedPXGivenT = list() # empty list to cach condProbsAdpt calculated by mml_fixed_str_adaptive()
for (i in 1:nvars) {
  if (i == targetIndex) {
    cachedPXGivenT[[i]] = probs_adaptive(data, arities, sampleSize, probsMtx, targetIndex)
  } else {
    cachedPXGivenT[[i]] = cond_probs_adaptive(data, arities, sampleSize, targetIndex, probsMtx, i, targetIndex)
  }
}

logProbTarget = sum(log(t(cachedPXGivenT[[targetIndex]])[cbind(seq_along(data[, targetIndex]), data[, targetIndex])]))

mml_fixed_str_adaptive(data, vars, arities, n, 3, logProbTarget, cachedPXGivenT, probsMtx, s1, c(1, 2), cachedPXGivenY, 
                       cachInd)

```








