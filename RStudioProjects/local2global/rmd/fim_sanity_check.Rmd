---
title: "FIM sanity check"
author: "kl"
date: "28 July 2017"
output: html_document
---

```{r setup, include=FALSE,eval=F}
knitr::opts_chunk$set(echo = TRUE)
if (.Platform$OS.type == "windows") {
  dir = "C:/Users/"
} else {
  dir = "/home/"
}
source(paste0(dir, "kl/Documents/PhDProjects/RStudioProjects/local2global/scripts/load_libraries.R"))
library(numDeriv)
```

```{r,eval=F}
dag = empty.graph(c("Y", "X1", "X2", "X3"))
dag = set.arc(dag, "Y", "X1")
dag = set.arc(dag, "Y", "X2")
dag = set.arc(dag, "Y", "X3")
dag = randDag(10, 2)
```

```{r}
# cpts = randCPTs(dag, 2, 1)
# sampleSize = 1000
# data = rbn(cpts, sampleSize)
temp = factor2numeric(data)
temp = abs(temp - 1)
# arities = sapply(data, nlevels)
# vars = names(data)
#x = c("X1")
#y = "Y"
#yIndex = which(colnames(data) == y)
#xIndices = which(colnames(data) %in% x)
#xx = c(pars$Y[[1]], pars$X1[1,1], pars$X1[1,2])
#xx = c(pars$Y[[1]], pars$X1[1,1], pars$X2[1,1], pars$X3[1,1], pars$X1[1,2], pars$X2[1,2], pars$X3[1,2])
# probSign = get_prob_sign(data)
```

## nll (conditional)
```{r}
#freeParms = c(pars[[2]][1], pars[[1]][1], pars[[1]][3]) # <p(Y=A), p(X=A|Y=A), p(X=A|Y=B)>
f = function(freeParms) {
  l = sum(table(data[,c(yIndex)]) * log(c(freeParms[length(freeParms)], 1 - freeParms[length(freeParms)])))
  #l2 = 0 
  for (j in 1:length(indices)) {
    vv = freeParms[((j - 1) * 2 + 1):(j * 2)]
    ww = 1 - freeParms[((j - 1) * 2 + 1):(j * 2)]
    xx = c()
    for (i in 1:length(vv)) {
      xx = c(xx, vv[i], ww[i])
    }
    l = l + sum(as.vector(table(data[,c(indices[j],yIndex)])) * log(xx)) 
  }
  
  v = c(pars[[1]][1, 1] * pars[[2]][1], pars[[1]][2, 1] * pars[[2]][1])
  w = c(pars[[1]][1, 2] * pars[[2]][2], pars[[1]][2, 2] * pars[[2]][2])
  names(w) = names(v) = c()
  l2 = sum(log(v + w) * as.vector(table(data[, c(indices)])))
  
  # cat(-l, "\n")
  # cat(l2, "\n")
  return(-l + l2)
}
# freeParms = unlist(pars) # <p(Y=A), p(Y=B), p(X=A|Y=A), p(X=B|Y=A), p(X=A|Y=B), p(X=B|Y=B), ...>
indices = c(3)
pars = mle_nb(data, vars, indices, yIndex, 0.5)
freeParms = c(pars[[1]][1], pars[[1]][3], pars[[2]][1])
names(freeParms) = c()
f(freeParms)

## hessian diagonal entries (based on derivation)

hhh = fim2 = matrix(0, 3,3)
hhh[1,1] = -(-sum(table(data[, yIndex]) / c(freeParms[length(freeParms)]^2, (1 - freeParms[length(freeParms)])^2)) + 
table(data[, indices])[1] * ((freeParms[1] - freeParms[2]) / (freeParms[1] * freeParms[3] + freeParms[2] * (1 - freeParms[3])))^2 + 
table(data[, indices])[2] * (((1 - freeParms[1]) - (1 - freeParms[2])) / ((1 - freeParms[1]) * freeParms[3] + (1 - freeParms[2]) * (1 - freeParms[3])))^2)

hhh[2,2] = -(-sum(table(data[, c(indices, yIndex)])[, 1] / c(freeParms[1]^2, (1 - freeParms[1])^2)) + 
table(data[, indices])[1] * (freeParms[3] / (freeParms[1] * freeParms[3] + freeParms[2] * (1 - freeParms[3])))^2 + 
table(data[, indices])[2] * (freeParms[3] / ((1 - freeParms[1]) * freeParms[3] + (1 - freeParms[2]) * (1 - freeParms[3])))^2)

hhh[3,3] = -(-sum(table(data[, c(indices, yIndex)])[, 2] / c(freeParms[2]^2, (1 - freeParms[2])^2)) + 
table(data[, indices])[1] * ((1 - freeParms[3]) / (freeParms[1] * freeParms[3] + freeParms[2] * (1 - freeParms[3])))^2 + 
table(data[, indices])[2] * ((1 - freeParms[3]) / ((1 - freeParms[1]) * freeParms[3] + (1 - freeParms[2]) * (1 - freeParms[3])))^2)

## hessian off-diagonal entries

hhh[1, 2] = - sum(c(-1, 1) * (table(data[, indices]) * c(freeParms[2], (1 - freeParms[2])) / (c(freeParms[1], (1 - freeParms[1])) * freeParms[3] + c(freeParms[2], (1 - freeParms[2])) * (1 - freeParms[3])) ^ 2))

hhh[1, 3] = - sum(c(1, -1) * (table(data[, indices]) * c(freeParms[1], (1 - freeParms[1])) / (c(freeParms[1], (1 - freeParms[1])) * freeParms[3] + c(freeParms[2], (1 - freeParms[2])) * (1 - freeParms[3])) ^ 2))

# - sum(c(-1, 1) * (table(data[, indices]) * (freeParms[3] ^ 2) / (c(freeParms[1], (1 - freeParms[1])) * freeParms[3] + c(freeParms[2], (1 - freeParms[2])) * (1 - freeParms[3])) ^ 2))

hhh[2, 3] = - sum(c(1, 1) * (table(data[, indices]) * freeParms[3] * (1 - freeParms[3]) / (c(freeParms[1], (1 - freeParms[1])) * freeParms[3] + c(freeParms[2], (1 - freeParms[2])) * (1 - freeParms[3])) ^ 2))

hhh[lower.tri(hhh)] = hhh[upper.tri(hhh)]

## expectation of hessian's diagonal entries

fim2 = hhh
fim2[1,1] = -(-sum(table(data[, indices]) * c(freeParms[1], 1 - freeParms[1]) / (freeParms[3] * c(freeParms[1] * freeParms[3] + freeParms[2] * (1 - freeParms[3]), (1 - freeParms[1]) * freeParms[3] + (1 - freeParms[2]) * (1 - freeParms[3])))) - sum(table(data[, indices]) * c(freeParms[2], 1 - freeParms[2]) / ((1 - freeParms[3]) * c(freeParms[1] * freeParms[3] + freeParms[2] * (1 - freeParms[3]), (1 - freeParms[1]) * freeParms[3] + (1 - freeParms[2]) * (1 - freeParms[3])))) + table(data[, indices])[1] * ((freeParms[1] - freeParms[2]) / (freeParms[1] * freeParms[3] + freeParms[2] * (1 - freeParms[3])))^2 + table(data[, indices])[2] * (((1 - freeParms[1]) - (1 - freeParms[2])) / ((1 - freeParms[1]) * freeParms[3] + (1 - freeParms[2]) * (1 - freeParms[3])))^2)

fim2[2,2] = -(-sum(n * freeParms[3] * c(freeParms[1], 1 - freeParms[1]) / c(freeParms[1]^2, (1 - freeParms[1])^2)) + table(data[, indices])[1] * (freeParms[3] / (freeParms[1] * freeParms[3] + freeParms[2] * (1 - freeParms[3])))^2 + table(data[, indices])[2] * (freeParms[3] / ((1 - freeParms[1]) * freeParms[3] + (1 - freeParms[2]) * (1 - freeParms[3])))^2)

fim2[3,3] = -(-sum(n * (1 - freeParms[3]) * c(freeParms[2], 1 - freeParms[2]) / c(freeParms[2]^2, (1 - freeParms[2])^2)) + table(data[, indices])[1] * ((1 - freeParms[3]) / (freeParms[1] * freeParms[3] + freeParms[2] * (1 - freeParms[3])))^2 + table(data[, indices])[2] * ((1 - freeParms[3]) / ((1 - freeParms[1]) * freeParms[3] + (1 - freeParms[2]) * (1 - freeParms[3])))^2)

hh = hessian(f, freeParms)

cat("fim", log(det(fim)), "\n")
cat("fim2", log(det(fim2)), "\n")
cat("hessian", log(det(hhh)), "\n")
```

# negative likelihood 
```{r,eval=T}
# f = function(xx) {
#   #dataPoint, pars, xIndices, yIndex) {
#   ss = 0
#   for (i in 1:nrow(data)) {
#     if (length(xIndices) > 0) {
#     for (j in 1:length(xIndices)) {
#       if (as.numeric(data[i, yIndex]) == 1) {
#         yy = log(abs(as.numeric(data[i, xIndices[j]]) - 1 - xx[2]))
#       } else {
#         yy = log(abs(as.numeric(data[i, xIndices[j]]) - 1 - xx[3]))
#       }
#       ss = ss - yy
#     }
#   }
#   ss = ss - log(abs(as.numeric(data[i, yIndex]) - 1 - xx[1]))
#   }
#   
#   return(ss)
# }

f = function(xx) {
  ss = 0
  for (i in 1:nrow(temp)) {
    yi = temp[i, 1]
    pi1 = xx[1]
    pij1 = abs(abs(temp[i, xIndices] - 1) - xx[xIndices])
    pij0 = abs(abs(temp[i, xIndices] - 1) - xx[xIndices + length(xIndices)])
    px = pi1 * prod(pij1) + (1 - pi1) * prod(pij0)
    ss = ss + yi * log(pi1) + (1 - yi) * log(1 - pi1) + yi * sum(log(pij1)) + (1 - yi) * sum(log(pij0)) - log(px)
    #cat(i, "-", ss, "\n")
  }
  return(-ss)
}
xIndices = indices
xx = c(pars[[2]][1], pars[[1]][1], pars[[1]][3])
f(xx)
```

```{r}
#grad(f, freeParms)

  
# yIndex = 1
xIndices = indices
  pars = mle_nb(data, vars, xIndices, yIndex, smoothing = 0.5) # mle of parameters with smoothing
  # negative log likelihood
  # this is partial nll if x is not empty
  nll = -sum(apply(data, 1, nll_nb, pars = pars, xIndices = xIndices, yIndex = yIndex))
  
  # p(y=T)
  py1 = pars[[length(pars)]][[1]]
  # p(y=F)
  py0 = pars[[length(pars)]][[2]]
  prodPij1 = apply(data, 1, prod_pijk, pars = pars, xIndices = xIndices, yValue = 1)
    # a vector of \prod_j p(x_ij|y=2nd value) = \prod_j p(x_ij|y=0)
    prodPij0 = apply(data, 1, prod_pijk, pars = pars, xIndices = xIndices, yValue = 2)
    # a vector of p_xi 
    px = py1 * prodPij1 + py0 * prodPij0
    nll = nll + sum(log(px)) # add additional log(px) value to nll when x is not empty
    # a matrix of p(x_j|y=T) and p(x_j|y=F)
    # parameters are in the order of <p_ij1, p_ij0>
    probsMatrix = c()
    for (yValue in 1:arities[yIndex]) {
      for (j in xIndices) {
        probsMatrix = 
          cbind(probsMatrix, apply(data, 1, p_ijk, pars = pars, xIndices = xIndices, xIndex = j, yValue = yValue))
      }
    }
    
    # FIM
    fim = fim_nb(probSign, prodPij1, prodPij0, px, probsMatrix, py1, py0, arities, xIndices, yIndex)
```

```{r}
pars
hh
(det(hh))
log(det(hh))
fim
(det(fim))
log(det(fim))
```
```{r}
hh = matrix(as.integer(hh), nrow = nrow(hh), ncol = ncol(hh))
(det(hh))
log(det(hh))
fim = matrix(as.integer(fim), nrow = nrow(fim), ncol = ncol(fim))
(det(fim))
log(det(fim))
```





