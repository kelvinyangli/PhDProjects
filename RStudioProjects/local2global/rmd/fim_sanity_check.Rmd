---
title: "FIM sanity check"
author: "kl"
date: "28 July 2017"
output: html_document
---

```{r setup, include=FALSE,eval=F}
knitr::opts_chunk$set(echo = TRUE)
if (.Platform$OS.type == "windows") {
  dir = "C:/Users/"
} else {
  dir = "/home/"
}
source(paste0(dir, "kl/Documents/PhDProjects/RStudioProjects/local2global/scripts/load_libraries.R"))
library(numDeriv)
```

```{r,eval=F}
dag = empty.graph(c("Y", "X1", "X2", "X3"))
dag = set.arc(dag, "Y", "X1")
dag = set.arc(dag, "Y", "X2")
dag = set.arc(dag, "Y", "X3")
dag = randDag(10, 2)
```

```{r}
# cpts = randCPTs(dag, 2, 1)
# sampleSize = 1000
# data = rbn(cpts, sampleSize)
temp = factor2numeric(data)
temp = abs(temp - 1)
# arities = sapply(data, nlevels)
# vars = names(data)
#x = c("X1")
#y = "Y"
#yIndex = which(colnames(data) == y)
#xIndices = which(colnames(data) %in% x)
#xx = c(pars$Y[[1]], pars$X1[1,1], pars$X1[1,2])
#xx = c(pars$Y[[1]], pars$X1[1,1], pars$X2[1,1], pars$X3[1,1], pars$X1[1,2], pars$X2[1,2], pars$X3[1,2])
# probSign = get_prob_sign(data)
```

# negative likelihood 
```{r,eval=T}
f = function(xx) {
  #dataPoint, pars, xIndices, yIndex) {
  ss = 0
  for (i in 1:nrow(data)) {
    if (length(xIndices) > 0) {
    for (j in 1:length(xIndices)) {
      if (as.numeric(data[i, yIndex]) == 1) {
        yy = log(abs(as.numeric(data[i, xIndices[j]]) - 1 - xx[2]))
      } else {
        yy = log(abs(as.numeric(data[i, xIndices[j]]) - 1 - xx[3]))
      }
      ss = ss - yy
    }
  }
  ss = ss - log(abs(as.numeric(data[i, yIndex]) - 1 - xx[1]))
  }
  
  return(ss)
}

# f = function(xx) {
#   ss = 0 
#   for (i in 1:nrow(temp)) {
#     yi = temp[i, 1]
#     pi1 = xx[1]
#     pij1 = abs(abs(temp[i, xIndices] - 1) - xx[xIndices])
#     pij0 = abs(abs(temp[i, xIndices] - 1) - xx[xIndices + length(xIndices)])
#     px = pi1 * prod(pij1) + (1 - pi1) * prod(pij0)
#     ss = ss + yi * log(pi1) + (1 - yi) * log(1 - pi1) + yi * sum(log(pij1)) + (1 - yi) * sum(log(pij0)) - log(px)
#     cat(i, "-", ss, "\n")
#   }
#   return(-ss)
# }
xIndices = indices
xx = c(pars[[2]][1], pars[[1]][1], pars[[1]][3])
f(xx)
```

```{r}
#hh = hessian(f, xx)
  
yIndex = 1
xIndices = 2
  pars = mle_nb(data, vars, xIndices, yIndex, smoothing = 0.5) # mle of parameters with smoothing
  # negative log likelihood
  # this is partial nll if x is not empty
  nll = -sum(apply(data, 1, nll_nb, pars = pars, xIndices = xIndices, yIndex = yIndex))
  
  # p(y=T)
  py1 = pars[[length(pars)]][[1]]
  # p(y=F)
  py0 = pars[[length(pars)]][[2]]
  prodPij1 = apply(data, 1, prod_pijk, pars = pars, xIndices = xIndices, yValue = 1)
    # a vector of \prod_j p(x_ij|y=2nd value) = \prod_j p(x_ij|y=0)
    prodPij0 = apply(data, 1, prod_pijk, pars = pars, xIndices = xIndices, yValue = 2)
    # a vector of p_xi 
    px = py1 * prodPij1 + py0 * prodPij0
    nll = nll + sum(log(px)) # add additional log(px) value to nll when x is not empty
    # a matrix of p(x_j|y=T) and p(x_j|y=F)
    # parameters are in the order of <p_ij1, p_ij0>
    probsMatrix = c()
    for (yValue in 1:arities[yIndex]) {
      for (j in xIndices) {
        probsMatrix = 
          cbind(probsMatrix, apply(data, 1, p_ijk, pars = pars, xIndices = xIndices, xIndex = j, yValue = yValue))
      }
    }
    
    # FIM
    fim = fim_nb(probSign, prodPij1, prodPij0, px, probsMatrix, py1, py0, arities, xIndices, yIndex)
```

```{r}
pars
hh
(det(hh))
log(det(hh))
fim
(det(fim))
log(det(fim))
```
```{r}
hh = matrix(as.integer(hh), nrow = nrow(hh), ncol = ncol(hh))
(det(hh))
log(det(hh))
fim = matrix(as.integer(fim), nrow = nrow(fim), ncol = ncol(fim))
(det(fim))
log(det(fim))
```





